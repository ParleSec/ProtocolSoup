/**
 * Dynamic Sitemap Generator
 * 
 * Automatically discovers all routes by parsing source files:
 * - Static routes from App.tsx
 * - Protocol/flow routes from Protocols.tsx
 * 
 * add protocols to Protocols.tsx and the sitemap updates automatically on build.
 */

import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const srcDir = join(__dirname, '..', 'src');
const publicDir = join(__dirname, '..', 'public');

const SITE_URL = 'https://protocolsoup.com';

// =============================================================================
// Parse Static Routes from App.tsx
// =============================================================================

function parseStaticRoutes() {
  const appPath = join(srcDir, 'App.tsx');
  const content = readFileSync(appPath, 'utf-8');
  
  const routes = [];
  
  // Match all <Route path="..." patterns
  const routeRegex = /<Route\s+path=["']([^"']+)["']/g;
  let match;
  
  while ((match = routeRegex.exec(content)) !== null) {
    const path = match[1];
    
    // Skip dynamic routes (contain :) and callback routes
    if (path.includes(':') || path === '/callback') {
      continue;
    }
    
    routes.push(path);
  }
  
  return routes;
}

// =============================================================================
// Parse Protocols from Protocols.tsx
// =============================================================================

function parseProtocols() {
  const protocolsPath = join(srcDir, 'pages', 'Protocols.tsx');
  const content = readFileSync(protocolsPath, 'utf-8');
  
  const protocols = [];
  
  // Extract the protocols array - match from 'const protocols = [' to the closing ']'
  const protocolsArrayMatch = content.match(/const\s+protocols\s*=\s*\[([\s\S]*?)\n\]/);
  
  if (!protocolsArrayMatch) {
    console.warn('⚠️  Could not parse protocols array from Protocols.tsx');
    return protocols;
  }
  
  const protocolsContent = protocolsArrayMatch[1];
  
  // Extract each protocol block
  const protocolBlockRegex = /\{\s*id:\s*['"]([^'"]+)['"][^}]*flows:\s*\[([\s\S]*?)\]\s*,?\s*\}/g;
  let protocolMatch;
  
  while ((protocolMatch = protocolBlockRegex.exec(protocolsContent)) !== null) {
    const protocolId = protocolMatch[1];
    const flowsContent = protocolMatch[2];
    
    // Extract flow IDs
    const flows = [];
    const flowIdRegex = /id:\s*['"]([^'"]+)['"]/g;
    let flowMatch;
    
    while ((flowMatch = flowIdRegex.exec(flowsContent)) !== null) {
      flows.push(flowMatch[1]);
    }
    
    protocols.push({ id: protocolId, flows });
  }
  
  return protocols;
}

// =============================================================================
// Generate All Sitemap Entries
// =============================================================================

function generateEntries() {
  const entries = [];
  const today = new Date().toISOString().split('T')[0];
  
  // Static routes
  const staticRoutes = parseStaticRoutes();
  for (const path of staticRoutes) {
    entries.push({
      url: `${SITE_URL}${path === '/' ? '' : path}`,
      lastmod: today,
      changefreq: 'weekly',
      priority: path === '/' ? 1.0 : 0.9,
    });
  }
  
  // Protocol and flow routes
  const protocols = parseProtocols();
  for (const protocol of protocols) {
    // Protocol overview page
    entries.push({
      url: `${SITE_URL}/protocol/${protocol.id}`,
      lastmod: today,
      changefreq: 'monthly',
      priority: 0.8,
    });
    
    // Flow detail pages
    for (const flowId of protocol.flows) {
      entries.push({
        url: `${SITE_URL}/protocol/${protocol.id}/flow/${flowId}`,
        lastmod: today,
        changefreq: 'monthly',
        priority: 0.7,
      });
    }
  }
  
  return { entries, staticCount: staticRoutes.length, protocols };
}

// =============================================================================
// Generate XML
// =============================================================================

function generateXml(entries) {
  const urlEntries = entries.map(entry => `  <url>
    <loc>${entry.url}</loc>
    <lastmod>${entry.lastmod}</lastmod>
    <changefreq>${entry.changefreq}</changefreq>
    <priority>${entry.priority.toFixed(1)}</priority>
  </url>`).join('\n');
  
  return `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9
        http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd">
  <!-- 
    Protocol Soup Sitemap
    Auto-generated: ${new Date().toISOString()}
    
    This file is automatically generated from source files.
    Routes parsed from: App.tsx, Protocols.tsx
  -->
${urlEntries}
</urlset>`;
}

// =============================================================================
// Main
// =============================================================================

function main() {
  console.log('Generating sitemap from source files...\n');
  
  try {
    const { entries, staticCount, protocols } = generateEntries();
    const xml = generateXml(entries);
    
    const outputPath = join(publicDir, 'sitemap.xml');
    writeFileSync(outputPath, xml, 'utf-8');
    
    const flowCount = protocols.reduce((sum, p) => sum + p.flows.length, 0);
    
    console.log(' Parsed sources:');
    console.log('   └─ src/App.tsx');
    console.log('   └─ src/pages/Protocols.tsx\n');
    
    console.log(` Generated sitemap.xml with ${entries.length} URLs:`);
    console.log(`   ├─ ${staticCount} static pages`);
    console.log(`   ├─ ${protocols.length} protocol pages`);
    console.log(`   └─ ${flowCount} flow pages\n`);
    
    console.log(' Discovered protocols:');
    for (const p of protocols) {
      console.log(`   └─ ${p.id} (${p.flows.length} flows)`);
    }
    
    console.log(`\n Output: public/sitemap.xml`);
    console.log('✨ Done!\n');
  } catch (error) {
    console.error('Failed to generate sitemap:', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

main();
