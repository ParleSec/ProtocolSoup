/**
 * Fallback Flow Data
 * 
 * This data is used when the API is unavailable (e.g., during development).
 * In production, all flow data should come from the backend plugins.
 * 
 * This ensures the frontend can work standalone while maintaining
 * the modular plugin architecture.
 */

import type { FlowStep } from './registry'

export interface FlowData {
  title: string
  description: string
  steps: FlowStep[]
}

export const fallbackFlows: Record<string, FlowData> = {
  authorization_code: {
    title: "Authorization Code Flow",
    description: "The standard OAuth 2.0 flow for server-side applications with a confidential client (RFC 6749 §4.1). The authorization code is exchanged server-to-server, keeping access tokens away from the browser.",
    steps: [
      {
        order: 1,
        name: "Authorization Request",
        description: "Client redirects user's browser to the Authorization Server's /authorize endpoint. The state parameter MUST be included to prevent CSRF attacks (RFC 6749 §10.12).",
        from: "Client",
        to: "Authorization Server",
        type: "redirect",
        parameters: {
          response_type: "code (REQUIRED - indicates Authorization Code flow)",
          client_id: "Client identifier issued during registration (REQUIRED)",
          redirect_uri: "URI to return user after authorization (REQUIRED)",
          scope: "Space-delimited list of requested permissions",
          state: "Opaque value for CSRF protection (REQUIRED for security)",
        },
        security: [
          "State parameter prevents CSRF attacks - must be cryptographically random",
          "Redirect URI must exactly match pre-registered URI",
          "HTTPS required in production to protect authorization code in transit",
        ],
      },
      {
        order: 2,
        name: "User Authentication",
        description: "Authorization Server authenticates the resource owner (user) via login form. This step is handled entirely by the Authorization Server - the Client never sees user credentials.",
        from: "User",
        to: "Authorization Server",
        type: "internal",
        parameters: {
          credentials: "Username/password or SSO (never exposed to Client)",
          mfa: "Multi-factor authentication if configured",
        },
        security: [
          "Client application NEVER handles user credentials",
          "Authentication method is determined by Authorization Server policy",
          "Failed login attempts should be rate-limited",
        ],
      },
      {
        order: 3,
        name: "User Consent",
        description: "Authorization Server displays consent screen showing requested scopes. User explicitly grants or denies access to their data.",
        from: "User",
        to: "Authorization Server",
        type: "internal",
        parameters: {
          scopes: "Permissions being requested (profile, email, etc.)",
          client_info: "Application name and verified publisher",
        },
        security: [
          "User must understand what access they are granting",
          "Consent may be remembered for trusted applications",
          "Scope should follow principle of least privilege",
        ],
      },
      {
        order: 4,
        name: "Authorization Code Response",
        description: "Authorization Server redirects user back to Client's redirect_uri with a short-lived authorization code (RFC 6749 §4.1.2). The code is single-use and expires quickly (~10 minutes).",
        from: "Authorization Server",
        to: "Client",
        type: "redirect",
        parameters: {
          code: "Single-use authorization code (short-lived, ~10 min)",
          state: "MUST match the original state value exactly",
        },
        security: [
          "Code is transmitted via browser redirect (front-channel) - keep it short-lived",
          "State mismatch indicates CSRF attack - abort flow immediately",
          "Code can only be used once - replay attacks are prevented",
        ],
      },
      {
        order: 5,
        name: "Token Exchange Request",
        description: "Client's backend server exchanges the authorization code for tokens via direct HTTPS request to the token endpoint (RFC 6749 §4.1.3). This is a back-channel request - browser is not involved.",
        from: "Client",
        to: "Authorization Server",
        type: "request",
        parameters: {
          grant_type: "authorization_code (REQUIRED)",
          code: "The authorization code received (REQUIRED)",
          redirect_uri: "Must match original authorization request (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          client_secret: "Client secret for confidential clients (REQUIRED)",
        },
        security: [
          "MUST use HTTPS - tokens are highly sensitive",
          "Content-Type MUST be application/x-www-form-urlencoded (RFC 6749 §4.1.3)",
          "Client authentication via client_secret or client_secret_basic header",
          "Back-channel request keeps tokens away from browser",
        ],
      },
      {
        order: 6,
        name: "Token Response",
        description: "Authorization Server validates the code, client credentials, and redirect_uri, then issues tokens (RFC 6749 §4.1.4). Access token is used for API calls; refresh token for renewal without user interaction.",
        from: "Authorization Server",
        to: "Client",
        type: "response",
        parameters: {
          access_token: "Bearer token for API authorization (REQUIRED)",
          token_type: "Bearer (REQUIRED)",
          expires_in: "Token lifetime in seconds (RECOMMENDED)",
          refresh_token: "For obtaining new access tokens (OPTIONAL)",
          scope: "Granted scopes if different from requested (OPTIONAL)",
        },
        security: [
          "Store tokens securely - never in localStorage or client-side code",
          "Access tokens should be short-lived (1 hour typical)",
          "Refresh tokens require secure server-side storage",
          "Use token introspection or JWT validation before trusting tokens",
        ],
      },
      {
        order: 7,
        name: "API Request with Token",
        description: "Client includes the access token in API requests to the Resource Server using the Authorization header with Bearer scheme (RFC 6750 §2.1).",
        from: "Client",
        to: "Resource Server",
        type: "request",
        parameters: {
          "Authorization": "Bearer {access_token}",
          "Accept": "application/json",
        },
        security: [
          "Always use HTTPS when transmitting access tokens",
          "Never include tokens in URL query parameters",
          "Implement token expiration handling with refresh flow",
        ],
      },
      {
        order: 8,
        name: "Protected Resource Response",
        description: "Resource Server validates the access token and returns the requested data. Token validation may use introspection (RFC 7662) or local JWT verification.",
        from: "Resource Server",
        to: "Client",
        type: "response",
        parameters: {
          data: "Requested protected resource",
          "Content-Type": "application/json",
        },
        security: [
          "Resource Server MUST validate token before returning data",
          "Check token expiration, scope, and audience claims",
          "Return 401 Unauthorized for invalid/expired tokens",
        ],
      },
    ]
  },

  authorization_code_pkce: {
    title: "Authorization Code + PKCE",
    description: "OAuth 2.0 Authorization Code flow with Proof Key for Code Exchange (RFC 7636). PKCE protects public clients (SPAs, mobile apps) that cannot securely store a client secret. It prevents authorization code interception attacks even if the code is stolen.",
    steps: [
      {
        order: 1,
        name: "Generate PKCE Parameters",
        description: "Client generates a cryptographically random code_verifier, then derives the code_challenge using SHA-256 (RFC 7636 §4.1). The verifier is stored securely; only the challenge is sent to the Authorization Server.",
        from: "Client",
        to: "Client",
        type: "internal",
        parameters: {
          code_verifier: "Cryptographic random string (43-128 chars, [A-Za-z0-9-._~])",
          code_challenge: "BASE64URL(SHA256(code_verifier)) = exactly 43 characters",
          code_challenge_method: "S256 (REQUIRED - SHA-256 hash, never use 'plain')",
        },
        security: [
          "code_verifier MUST be 43-128 characters (RFC 7636 §4.1)",
          "Only characters [A-Za-z0-9-._~] allowed in verifier",
          "Use cryptographically secure random generator (crypto.getRandomValues)",
          "Store verifier securely until token exchange completes",
        ],
      },
      {
        order: 2,
        name: "Authorization Request with Challenge",
        description: "Client redirects user to Authorization Server with the code_challenge (never the verifier). The challenge binds this authorization request to the specific client instance that generated the verifier.",
        from: "Client",
        to: "Authorization Server",
        type: "redirect",
        parameters: {
          response_type: "code (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          redirect_uri: "Callback URI (REQUIRED)",
          code_challenge: "BASE64URL(SHA256(verifier)) - 43 chars (REQUIRED)",
          code_challenge_method: "S256 (REQUIRED - always use SHA-256)",
          state: "CSRF protection token (REQUIRED)",
          scope: "Requested permissions",
        },
        security: [
          "NEVER send code_verifier to authorization endpoint",
          "code_challenge binds the request to your specific client instance",
          "S256 method is required - plain method is vulnerable",
          "State parameter still required for CSRF protection",
        ],
      },
      {
        order: 3,
        name: "User Authentication & Consent",
        description: "User authenticates with the Authorization Server and grants permission. Client never sees user credentials. Authorization Server stores the code_challenge for later verification.",
        from: "User",
        to: "Authorization Server",
        type: "internal",
        parameters: {
          authentication: "User credentials (never exposed to client)",
          consent: "User grants or denies requested scopes",
        },
        security: [
          "Authorization Server stores code_challenge with the authorization code",
          "Challenge is associated with this specific authorization request",
        ],
      },
      {
        order: 4,
        name: "Authorization Code Response",
        description: "Authorization Server redirects back to client with authorization code. The code is bound to the code_challenge that was submitted - only the holder of the original verifier can exchange it.",
        from: "Authorization Server",
        to: "Client",
        type: "redirect",
        parameters: {
          code: "Single-use authorization code (bound to challenge)",
          state: "MUST match original state value",
        },
        security: [
          "Even if code is intercepted, attacker cannot exchange it without verifier",
          "Verify state parameter before proceeding",
          "Code is single-use and short-lived (~10 minutes)",
        ],
      },
      {
        order: 5,
        name: "Token Exchange with Verifier",
        description: "Client exchanges authorization code with the original code_verifier as proof of possession (RFC 7636 §4.5). The server hashes the verifier and compares to stored challenge.",
        from: "Client",
        to: "Authorization Server",
        type: "request",
        parameters: {
          grant_type: "authorization_code (REQUIRED)",
          code: "The authorization code (REQUIRED)",
          redirect_uri: "Must match original request (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          code_verifier: "Original random string 43-128 chars (REQUIRED)",
        },
        security: [
          "Server computes SHA256(code_verifier) and compares to stored challenge",
          "Mismatch proves the requester is not the original client",
          "No client_secret needed - PKCE provides client authentication",
          "Content-Type MUST be application/x-www-form-urlencoded",
        ],
      },
      {
        order: 6,
        name: "Token Response",
        description: "After verifying the code_verifier matches the stored code_challenge, the Authorization Server issues tokens. This completes the PKCE flow with proof of client identity.",
        from: "Authorization Server",
        to: "Client",
        type: "response",
        parameters: {
          access_token: "Bearer token for API access (REQUIRED)",
          token_type: "Bearer (REQUIRED)",
          expires_in: "Token lifetime in seconds (RECOMMENDED)",
          refresh_token: "For token renewal (OPTIONAL)",
          scope: "Granted scopes if different from requested",
        },
        security: [
          "Tokens are only issued after successful PKCE verification",
          "Store access token securely (httpOnly cookie or secure storage)",
          "For SPAs: consider using refresh token rotation",
          "Clear verifier from memory after successful exchange",
        ],
      },
    ]
  },

  client_credentials: {
    title: "Client Credentials Grant",
    description: "Machine-to-machine (M2M) authentication for server-side applications (RFC 6749 §4.4). The client authenticates using its own credentials (not user credentials) to access resources it owns or has been granted permission to access. No user interaction required.",
    steps: [
      {
        order: 1,
        name: "Token Request",
        description: "Client authenticates directly to the token endpoint using its client_id and client_secret. This is a confidential client flow - credentials must never be exposed to browsers or end users.",
        from: "Client (Backend Service)",
        to: "Authorization Server",
        type: "request",
        parameters: {
          grant_type: "client_credentials (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          client_secret: "Client secret (REQUIRED for confidential clients)",
          scope: "Requested permissions (OPTIONAL)",
        },
        security: [
          "ONLY for confidential clients (server-side) - never SPAs/mobile",
          "Client credentials must be stored securely (environment variables, vault)",
          "Use TLS/HTTPS - credentials are transmitted in request body",
          "Content-Type MUST be application/x-www-form-urlencoded",
          "Consider using client_secret_basic (Authorization header) instead",
        ],
      },
      {
        order: 2,
        name: "Access Token Response",
        description: "Authorization Server validates client credentials and issues access token. No refresh token is issued since the client can always re-authenticate with its credentials.",
        from: "Authorization Server",
        to: "Client (Backend Service)",
        type: "response",
        parameters: {
          access_token: "Bearer token for API access (REQUIRED)",
          token_type: "Bearer (REQUIRED)",
          expires_in: "Token lifetime in seconds (RECOMMENDED)",
          scope: "Granted scopes if different from requested",
        },
        security: [
          "No refresh token issued - client can re-request with credentials",
          "Token represents client identity, not a user",
          "Scopes should be limited to what the service actually needs",
          "Implement token caching to avoid excessive token requests",
        ],
      },
      {
        order: 3,
        name: "API Request",
        description: "Client uses the access token to authenticate API requests. The token represents the client application, not an end user.",
        from: "Client (Backend Service)",
        to: "Resource Server",
        type: "request",
        parameters: {
          "Authorization": "Bearer {access_token}",
        },
        security: [
          "Resource Server validates token before processing request",
          "Check 'sub' claim identifies the client, not a user",
          "Implement appropriate rate limiting per client",
        ],
      },
    ]
  },

  refresh_token: {
    title: "Refresh Token Flow",
    description: "Obtain new access tokens without user interaction using a refresh token (RFC 6749 §6). Refresh tokens are long-lived credentials that allow the client to maintain access after the access token expires.",
    steps: [
      {
        order: 1,
        name: "Refresh Token Request",
        description: "When the access token expires or is about to expire, the client sends the refresh token to obtain a new access token. This happens without user involvement.",
        from: "Client",
        to: "Authorization Server",
        type: "request",
        parameters: {
          grant_type: "refresh_token (REQUIRED)",
          refresh_token: "The refresh token (REQUIRED)",
          scope: "Requested scopes (OPTIONAL - same or subset of original)",
          client_id: "Client identifier (REQUIRED for public clients)",
          client_secret: "Client secret (REQUIRED for confidential clients)",
        },
        security: [
          "Refresh tokens are highly sensitive - store securely (encrypted, server-side)",
          "Never expose refresh tokens to client-side JavaScript",
          "Consider refresh token rotation (new refresh token each use)",
          "Content-Type MUST be application/x-www-form-urlencoded",
        ],
      },
      {
        order: 2,
        name: "New Token Response",
        description: "Authorization Server validates the refresh token and issues new tokens. Many implementations use refresh token rotation - issuing a new refresh token and invalidating the old one.",
        from: "Authorization Server",
        to: "Client",
        type: "response",
        parameters: {
          access_token: "New access token (REQUIRED)",
          token_type: "Bearer (REQUIRED)",
          expires_in: "Token lifetime in seconds (RECOMMENDED)",
          refresh_token: "New refresh token (OPTIONAL - rotation)",
          scope: "Granted scopes (OPTIONAL)",
        },
        security: [
          "Refresh token rotation prevents token replay attacks",
          "If rotation enabled, old refresh token is invalidated",
          "Detect and revoke all tokens if refresh token reuse detected",
          "Consider binding refresh tokens to client instance (DPoP)",
        ],
      },
      {
        order: 3,
        name: "Token Rotation Detection",
        description: "If refresh token rotation is enabled and a previously used refresh token is presented, this indicates potential token theft. The Authorization Server should revoke all tokens for that grant.",
        from: "Authorization Server",
        to: "Authorization Server",
        type: "internal",
        parameters: {
          detection: "Replay of already-used refresh token",
          action: "Revoke all tokens for this authorization grant",
        },
        security: [
          "Automatic breach detection via rotation tracking",
          "All tokens revoked forces user to re-authenticate",
          "Log and alert on detected replay attempts",
        ],
      },
    ]
  },

  token_introspection: {
    title: "Token Introspection (RFC 7662)",
    description: "Allows a Resource Server to query the Authorization Server about the current state of an access token. Returns metadata including whether the token is active, its scopes, subject, and expiration. Essential for opaque tokens and revocation checking.",
    steps: [
      {
        order: 1,
        name: "Introspection Request",
        description: "Resource Server sends the token to the Authorization Server's introspection endpoint. The Resource Server must authenticate itself (it's a protected endpoint).",
        from: "Resource Server",
        to: "Authorization Server",
        type: "request",
        parameters: {
          token: "The token to introspect (REQUIRED)",
          token_type_hint: "access_token or refresh_token (OPTIONAL - advisory)",
          client_id: "Resource Server's client ID (for authentication)",
          client_secret: "Resource Server's secret (for authentication)",
        },
        security: [
          "Introspection endpoint MUST be protected - requires client authentication",
          "token_type_hint is advisory - server may check both types",
          "Use HTTPS - tokens are transmitted in request body",
          "Content-Type MUST be application/x-www-form-urlencoded",
        ],
      },
      {
        order: 2,
        name: "Token Validation",
        description: "Authorization Server validates the token: checks signature (if JWT), expiration, and whether it has been revoked. Revoked tokens return active: false.",
        from: "Authorization Server",
        to: "Authorization Server",
        type: "internal",
        parameters: {
          signature: "Verify JWT signature using private key",
          expiration: "Check exp claim against current time",
          revocation: "Check if JTI is in revocation blacklist (RFC 7009)",
        },
      },
      {
        order: 3,
        name: "Introspection Response",
        description: "Authorization server returns token metadata and validity status. Revoked tokens return active=false.",
        from: "Authorization Server",
        to: "Resource Server",
        type: "response",
        parameters: {
          active: "Boolean - false if expired, revoked, or invalid",
          scope: "Granted scopes",
          client_id: "Client that requested token",
          username: "Resource owner (if applicable)",
          exp: "Expiration timestamp",
          iat: "Issued-at timestamp",
          jti: "Token unique identifier",
          sub: "Subject identifier",
          aud: "Intended audience",
          iss: "Token issuer",
        },
      },
      {
        order: 4,
        name: "Access Decision",
        description: "Resource server uses introspection result to authorize the request.",
        from: "Resource Server",
        to: "Resource Server",
        type: "internal",
        parameters: {
          check: "active === true (covers expiration + revocation)",
          verify: "scope includes required permissions",
          security: "Introspection is authoritative for token status",
        },
      },
    ]
  },

  token_revocation: {
    title: "Token Revocation",
    description: "Invalidate access or refresh tokens before their natural expiration. Essential for logout flows and security incident response (RFC 7009). Supports both access and refresh token revocation.",
    steps: [
      {
        order: 1,
        name: "Revocation Request",
        description: "Client sends token to revocation endpoint. Server MUST attempt revocation regardless of token_type_hint (RFC 7009 §2.1).",
        from: "Client",
        to: "Authorization Server",
        type: "request",
        parameters: {
          token: "The token to revoke (access or refresh)",
          token_type_hint: "Advisory only - 'refresh_token' or 'access_token' (RFC 7009 §2.1)",
          client_id: "Your client identifier",
          client_secret: "Your client secret (if confidential)",
          "Content-Type": "application/x-www-form-urlencoded (required)",
        },
      },
      {
        order: 2,
        name: "Revocation Response",
        description: "Server acknowledges revocation (200 OK even if token was already invalid or unknown - prevents token validity probing).",
        from: "Authorization Server",
        to: "Client",
        type: "response",
        parameters: {
          status: "200 OK (always, per RFC 7009 §2.2)",
          note: "No body content on success",
          security: "Prevents attackers from determining token validity",
        },
      },
      {
        order: 3,
        name: "Token Invalidated",
        description: "Both access and refresh tokens can be revoked. Introspection returns active=false for revoked tokens.",
        from: "Authorization Server",
        to: "Authorization Server",
        type: "internal",
        parameters: {
          cascade: "Revoking refresh token may revoke associated access tokens",
          access_tokens: "Tracked via JTI claim in token blacklist",
          security: "Prevents token reuse after logout or compromise",
        },
      },
    ]
  },

  oidc_authorization_code: {
    title: "OIDC Authorization Code Flow",
    description: "OpenID Connect 1.0 authentication using the OAuth 2.0 Authorization Code flow (OIDC Core §3.1). Adds an ID Token containing identity claims about the authenticated user. Most secure flow for server-side applications.",
    steps: [
      {
        order: 1,
        name: "Discovery Document Fetch",
        description: "Client fetches the OpenID Provider's configuration from the well-known endpoint (OIDC Discovery §4). This document contains all endpoint URLs, supported scopes, and cryptographic capabilities.",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          endpoint: "/.well-known/openid-configuration",
          issuer: "Base URL of the OpenID Provider",
        },
        security: [
          "Cache the discovery document - it rarely changes",
          "Verify issuer in discovery matches expected value",
          "HTTPS required for discovery endpoint",
        ],
      },
      {
        order: 2,
        name: "JWKS Fetch",
        description: "Client fetches the JSON Web Key Set (JWKS) containing public keys for token signature verification (OIDC Core §10.1). Keys are identified by 'kid' (key ID) in token headers.",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          endpoint: "jwks_uri from discovery document",
          keys: "Array of JWK objects (RSA, EC, etc.)",
        },
        security: [
          "Cache JWKS with appropriate TTL (hours to days)",
          "Implement key rotation handling - refetch on unknown kid",
          "Match 'kid' from token header to correct key",
        ],
      },
      {
        order: 3,
        name: "Authentication Request",
        description: "Client redirects user to the authorization_endpoint with 'openid' scope (OIDC Core §3.1.2.1). The 'nonce' parameter is REQUIRED for replay protection - it binds the ID Token to this specific request.",
        from: "Client",
        to: "OpenID Provider",
        type: "redirect",
        parameters: {
          response_type: "code (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          redirect_uri: "Callback URI (REQUIRED)",
          scope: "openid (REQUIRED) + profile email address phone",
          state: "CSRF protection token (REQUIRED for security)",
          nonce: "Replay attack prevention (REQUIRED - returned in ID Token)",
          prompt: "none|login|consent|select_account (OPTIONAL)",
          max_age: "Maximum authentication age in seconds (OPTIONAL)",
          acr_values: "Requested authentication context class (OPTIONAL)",
        },
        security: [
          "nonce MUST be cryptographically random - binds ID Token to session",
          "state prevents CSRF - must be validated on callback",
          "Use PKCE for public clients (SPAs, mobile)",
          "Scope 'openid' is REQUIRED to trigger OIDC flow",
        ],
      },
      {
        order: 4,
        name: "End-User Authentication",
        description: "User authenticates with the OpenID Provider using their credentials. The OP determines authentication method (password, MFA, passkey, SSO). Client never sees user credentials.",
        from: "User",
        to: "OpenID Provider",
        type: "internal",
        parameters: {
          authentication: "Password, MFA, biometric, SSO, etc.",
          auth_time: "Timestamp recorded for ID Token auth_time claim",
        },
        security: [
          "Relying Party NEVER handles user credentials",
          "OP may skip authentication if SSO session exists",
          "max_age parameter can force re-authentication",
        ],
      },
      {
        order: 5,
        name: "User Consent",
        description: "User reviews and approves requested scopes. The OP shows what information will be shared (profile, email, etc.). User can deny access.",
        from: "User",
        to: "OpenID Provider",
        type: "internal",
        parameters: {
          scopes: "Requested claims based on scopes",
          consent: "Grant or deny access to claims",
        },
        security: [
          "Consent may be remembered for trusted applications",
          "prompt=consent forces consent screen even if previously granted",
        ],
      },
      {
        order: 6,
        name: "Authorization Code Response",
        description: "OpenID Provider redirects back with authorization code (OIDC Core §3.1.2.5). The code is bound to the client and nonce. Single-use, short-lived (~10 minutes).",
        from: "OpenID Provider",
        to: "Client",
        type: "redirect",
        parameters: {
          code: "Single-use authorization code (short-lived)",
          state: "MUST match original state exactly",
        },
        security: [
          "Verify state before proceeding - mismatch = CSRF attack",
          "Code is single-use - replay protection built-in",
          "Code is transmitted via browser - keep short-lived",
        ],
      },
      {
        order: 7,
        name: "Token Request",
        description: "Client exchanges code for tokens at the token_endpoint via back-channel HTTPS request (OIDC Core §3.1.3.1). Browser is not involved - tokens stay server-side.",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          grant_type: "authorization_code (REQUIRED)",
          code: "The authorization code (REQUIRED)",
          redirect_uri: "Must match original request (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          client_secret: "Client secret for confidential clients",
        },
        security: [
          "MUST use HTTPS for token endpoint",
          "Content-Type MUST be application/x-www-form-urlencoded",
          "Back-channel request keeps tokens away from browser",
          "Use PKCE code_verifier instead of client_secret for public clients",
        ],
      },
      {
        order: 8,
        name: "Token Response with ID Token",
        description: "OpenID Provider returns access_token AND id_token (OIDC Core §3.1.3.3). The ID Token is a signed JWT containing identity claims about the authenticated user.",
        from: "OpenID Provider",
        to: "Client",
        type: "response",
        parameters: {
          access_token: "For accessing protected resources (UserInfo, APIs)",
          token_type: "Bearer",
          id_token: "JWT with identity claims (sub, iss, aud, exp, iat, nonce)",
          expires_in: "Access token lifetime in seconds",
          refresh_token: "For token renewal (if granted)",
        },
        security: [
          "ID Token MUST be validated before trusting claims",
          "Store tokens securely - server-side, encrypted",
          "Access token used for UserInfo, APIs",
          "ID Token used for authentication - do not send to APIs",
        ],
      },
      {
        order: 9,
        name: "ID Token Validation",
        description: "Client MUST validate the ID Token before trusting it (OIDC Core §3.1.3.7). Verify signature using JWKS, then validate all required claims including nonce.",
        from: "Client",
        to: "Client",
        type: "internal",
        parameters: {
          signature: "Verify using public key from JWKS (match kid)",
          iss: "MUST match OP's issuer exactly",
          aud: "MUST contain this client's client_id",
          azp: "If present, MUST equal client_id",
          exp: "MUST NOT be expired (with clock skew tolerance)",
          iat: "SHOULD be recent (detect old tokens)",
          nonce: "MUST match value sent in authentication request",
          auth_time: "If max_age was sent, verify authentication is recent",
        },
        security: [
          "NEVER skip any validation step",
          "nonce validation prevents replay attacks",
          "azp required if multiple audiences present",
          "Use clock skew tolerance (~5 minutes) for exp/iat",
        ],
      },
      {
        order: 10,
        name: "UserInfo Request (Optional)",
        description: "Client can request additional claims from the userinfo_endpoint using the access token (OIDC Core §5.3). Returns claims based on granted scopes.",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          "Authorization": "Bearer {access_token}",
          "Accept": "application/json",
        },
        security: [
          "Sub claim in UserInfo MUST match sub in ID Token",
          "Use UserInfo for claims not in ID Token",
          "Consider UserInfo claims less authoritative than ID Token",
        ],
      },
      {
        order: 11,
        name: "UserInfo Response",
        description: "OpenID Provider returns additional user claims based on scopes: profile (name, picture), email (email, email_verified), phone (phone_number), address.",
        from: "OpenID Provider",
        to: "Client",
        type: "response",
        parameters: {
          sub: "Subject identifier (MUST match ID Token)",
          name: "Full name (profile scope)",
          email: "Email address (email scope)",
          email_verified: "Boolean - email verified (email scope)",
          picture: "Profile picture URL (profile scope)",
          phone_number: "Phone number (phone scope)",
        },
        security: [
          "MUST verify sub matches ID Token before using claims",
          "email_verified=false means email is unverified",
          "Don't use email as primary identifier - use sub",
        ],
      },
    ]
  },

  oidc_implicit: {
    title: "OIDC Implicit Flow (Legacy)",
    description: "OpenID Connect Implicit flow returns tokens directly from the authorization endpoint (OIDC Core §3.2). ⚠️ DEPRECATED: Not recommended for new applications due to token exposure in browser history and URL. Use Authorization Code + PKCE instead.",
    steps: [
      {
        order: 1,
        name: "Authentication Request",
        description: "Client redirects user to authorization endpoint requesting tokens directly (no code exchange). The nonce parameter is REQUIRED when response_type includes 'id_token' (OIDC Core §3.2.2.1).",
        from: "Client",
        to: "OpenID Provider",
        type: "redirect",
        parameters: {
          response_type: "id_token token (both) or id_token (ID token only)",
          client_id: "Client identifier (REQUIRED)",
          redirect_uri: "Callback URI (REQUIRED)",
          scope: "openid (REQUIRED) + profile email etc.",
          state: "CSRF protection token (REQUIRED)",
          nonce: "Replay protection (REQUIRED for id_token response types)",
          response_mode: "fragment (default - tokens in URL #fragment)",
        },
        security: [
          "⚠️ DEPRECATED: Use Authorization Code + PKCE for new applications",
          "Nonce is REQUIRED to bind ID Token to session (replay protection)",
          "Tokens will be exposed in browser history",
          "No refresh tokens are issued in implicit flow",
        ],
      },
      {
        order: 2,
        name: "End-User Authentication & Consent",
        description: "User authenticates with the OpenID Provider and grants permission. Client never sees credentials.",
        from: "User",
        to: "OpenID Provider",
        type: "internal",
        parameters: {
          authentication: "User credentials (never exposed to client)",
          consent: "User grants requested scopes",
        },
      },
      {
        order: 3,
        name: "Token Response via Fragment",
        description: "Tokens returned in URL fragment (#) - fragment is NOT sent to server, only accessible via JavaScript. ID Token includes at_hash when access_token is also returned (OIDC Core §3.2.2.9).",
        from: "OpenID Provider",
        to: "Client",
        type: "redirect",
        parameters: {
          id_token: "JWT with identity claims (REQUIRED)",
          access_token: "For API access (if 'token' in response_type)",
          token_type: "Bearer",
          expires_in: "Access token lifetime in seconds",
          state: "MUST match original value",
          at_hash: "Access Token hash in ID Token (if access_token present)",
        },
        security: [
          "Tokens visible in browser history and logs - security risk",
          "Fragment prevents tokens from being sent to redirect_uri server",
          "at_hash binds access_token to ID Token - validate it",
          "No refresh tokens - user must re-authenticate when expired",
        ],
      },
      {
        order: 4,
        name: "ID Token Validation",
        description: "Client MUST validate the ID Token before trusting claims (OIDC Core §3.2.2.11). Validation is critical as token came through front-channel.",
        from: "Client",
        to: "Client",
        type: "internal",
        parameters: {
          signature: "Verify using public key from JWKS (match kid)",
          iss: "MUST match OP's issuer exactly",
          aud: "MUST contain client_id",
          exp: "MUST NOT be expired",
          iat: "SHOULD be recent",
          nonce: "MUST match value sent in authentication request",
          at_hash: "If access_token present: BASE64URL(left-half(SHA256(access_token)))",
        },
        security: [
          "NEVER skip validation - tokens came through untrusted channel",
          "nonce validation is CRITICAL for replay attack prevention",
          "at_hash validation ensures access_token wasn't swapped",
          "Consider switching to Authorization Code + PKCE",
        ],
      },
    ]
  },

  oidc_hybrid: {
    title: "OIDC Hybrid Flow",
    description: "Combines Authorization Code and Implicit flows (OIDC Core §3.3). Returns ID Token immediately for fast identity verification while authorization code is exchanged securely server-side. Useful when client needs identity before backend token exchange completes.",
    steps: [
      {
        order: 1,
        name: "Authentication Request",
        description: "Request both authorization code and tokens. The response_type determines what is returned immediately vs via token exchange (OIDC Core §3.3.2.1).",
        from: "Client",
        to: "OpenID Provider",
        type: "redirect",
        parameters: {
          response_type: "'code id_token' | 'code token' | 'code id_token token' (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          redirect_uri: "Callback URI (REQUIRED)",
          scope: "openid (REQUIRED) + profile email etc.",
          state: "CSRF protection token (REQUIRED)",
          nonce: "Replay protection (REQUIRED when id_token in response_type)",
          response_mode: "fragment (default) - tokens in fragment, code in query or fragment",
        },
        security: [
          "nonce REQUIRED when response_type includes 'id_token'",
          "Hybrid combines benefits of both flows with some complexity",
          "Consider if simple Authorization Code + PKCE meets your needs",
        ],
      },
      {
        order: 2,
        name: "End-User Authentication & Consent",
        description: "User authenticates with the OpenID Provider and grants permission. OpenID Provider generates code and tokens based on response_type.",
        from: "User",
        to: "OpenID Provider",
        type: "internal",
        parameters: {
          authentication: "User credentials",
          consent: "User grants requested scopes",
        },
      },
      {
        order: 3,
        name: "Hybrid Response with Hash Claims",
        description: "ID Token returned immediately with hash claims for integrity verification. c_hash binds ID Token to authorization code; at_hash binds to access_token (OIDC Core §3.3.2.11).",
        from: "OpenID Provider",
        to: "Client",
        type: "redirect",
        parameters: {
          code: "Authorization code (for backend token exchange)",
          id_token: "JWT with identity claims (immediate)",
          access_token: "If 'token' in response_type (immediate)",
          token_type: "Bearer",
          state: "MUST match original value",
          c_hash: "Code hash in ID Token: BASE64URL(left-half(SHA256(code)))",
          at_hash: "Access Token hash in ID Token (if access_token present)",
        },
        security: [
          "c_hash MUST be validated to detect code tampering",
          "at_hash MUST be validated if access_token is present",
          "Immediate ID Token allows fast identity verification",
          "Authorization code still exchanged securely server-side",
        ],
      },
      {
        order: 4,
        name: "Validate ID Token with Hash Claims",
        description: "Client validates ID Token including c_hash and at_hash to ensure integrity of all front-channel tokens (OIDC Core §3.3.2.12).",
        from: "Client",
        to: "Client",
        type: "internal",
        parameters: {
          signature: "Verify using public key from JWKS",
          iss: "MUST match OP's issuer exactly",
          aud: "MUST contain client_id",
          nonce: "MUST match original request nonce",
          c_hash: "Compute SHA256(code), take left half, base64url encode, compare",
          at_hash: "Compute SHA256(access_token), take left half, base64url encode, compare",
          azp: "If aud has multiple values, azp MUST equal client_id",
        },
        security: [
          "Hash validation detects token substitution attacks",
          "If c_hash fails, DO NOT exchange the authorization code",
          "If at_hash fails, DO NOT use the access_token",
          "azp claim identifies the authorized party when multiple audiences",
        ],
      },
      {
        order: 5,
        name: "Token Exchange (Backend)",
        description: "Exchange authorization code for tokens via secure back-channel. This may return a fresh access_token with longer lifetime than the immediate one.",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          grant_type: "authorization_code (REQUIRED)",
          code: "The authorization code (REQUIRED)",
          redirect_uri: "Must match original (REQUIRED)",
          client_id: "Client identifier (REQUIRED)",
          client_secret: "Client secret for confidential clients",
        },
        security: [
          "Back-channel exchange is more secure than front-channel",
          "Refresh token is typically only returned here, not in fragment",
          "Access token from exchange may have different lifetime/scopes",
        ],
      },
      {
        order: 6,
        name: "Token Response",
        description: "Receive access_token, id_token, and optionally refresh_token from token endpoint. The exchanged tokens may differ from immediate tokens.",
        from: "OpenID Provider",
        to: "Client",
        type: "response",
        parameters: {
          access_token: "Bearer token for API access",
          token_type: "Bearer",
          expires_in: "Token lifetime in seconds",
          refresh_token: "For token renewal (not returned in fragment)",
          id_token: "May be returned again with updated claims",
        },
        security: [
          "Refresh token ONLY returned via back-channel (not in fragment)",
          "Store tokens securely server-side",
          "Compare sub claim in both ID Tokens - must match",
        ],
      },
    ]
  },

  oidc_userinfo: {
    title: "UserInfo Endpoint",
    description: "Protected resource that returns claims about the authenticated End-User (OIDC Core §5.3). Access requires a valid access token with 'openid' scope. Returns claims based on granted scopes (profile, email, address, phone).",
    steps: [
      {
        order: 1,
        name: "UserInfo Request",
        description: "Client requests claims about the authenticated user using the access_token obtained from a prior authentication (OIDC Core §5.3.1). GET or POST methods are supported.",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          method: "GET (REQUIRED to support) or POST",
          "Authorization": "Bearer {access_token} (REQUIRED)",
          endpoint: "userinfo_endpoint from discovery document",
          "Accept": "application/json (or application/jwt)",
        },
        security: [
          "Access token MUST have 'openid' scope",
          "Token is sent via Authorization header (preferred) or POST body",
          "HTTPS is REQUIRED for transmitting access tokens",
          "Response may be signed JWT if requested",
        ],
      },
      {
        order: 2,
        name: "Token Validation & User Lookup",
        description: "OpenID Provider validates the access token and retrieves the associated user record. Checks token expiration, scope, and revocation status.",
        from: "OpenID Provider",
        to: "OpenID Provider",
        type: "internal",
        parameters: {
          validate: "Token signature and expiration",
          scope: "Verify 'openid' scope is present",
          subject: "Look up user by 'sub' claim in token",
          claims: "Determine which claims to return based on scopes",
        },
        security: [
          "Token validation includes revocation check",
          "Only claims matching granted scopes are returned",
          "Claims filtering based on client registration",
        ],
      },
      {
        order: 3,
        name: "UserInfo Response",
        description: "Returns claims about the End-User as JSON or JWT. The 'sub' claim is always present and MUST match the ID Token (OIDC Core §5.3.2).",
        from: "OpenID Provider",
        to: "Client",
        type: "response",
        parameters: {
          sub: "Subject identifier - ALWAYS present, MUST match ID Token",
          name: "Full name (profile scope)",
          given_name: "First name (profile scope)",
          family_name: "Last name (profile scope)",
          preferred_username: "Username (profile scope)",
          email: "Email address (email scope)",
          email_verified: "Boolean - is email verified? (email scope)",
          picture: "Profile picture URL (profile scope)",
          phone_number: "Phone number (phone scope)",
          phone_number_verified: "Boolean - is phone verified? (phone scope)",
          address: "Address object (address scope)",
          updated_at: "Last profile update Unix timestamp",
        },
        security: [
          "MUST verify 'sub' matches ID Token before using claims",
          "email_verified=false means email is unverified - do not trust for account recovery",
          "Use 'sub' as primary identifier, not email (email can change)",
          "Consider claims from UserInfo less authoritative than ID Token",
        ],
      },
    ]
  },

  oidc_discovery: {
    title: "OpenID Connect Discovery",
    description: "Auto-configuration mechanism that allows Relying Parties to discover the OpenID Provider's endpoints, supported features, and cryptographic capabilities (OIDC Discovery §4). Essential for dynamic client registration and multi-provider support.",
    steps: [
      {
        order: 1,
        name: "Discovery Document Request",
        description: "Client fetches the OpenID Provider Configuration from the well-known endpoint (OIDC Discovery §4.1). URL is constructed from issuer: {issuer}/.well-known/openid-configuration",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          endpoint: "/.well-known/openid-configuration",
          method: "GET",
          "Accept": "application/json",
        },
        security: [
          "HTTPS required - document contains security-critical endpoints",
          "Cache the response - it changes infrequently",
          "Verify 'issuer' in response matches expected value exactly",
        ],
      },
      {
        order: 2,
        name: "Configuration Response",
        description: "Returns comprehensive metadata about the OpenID Provider including all endpoints, supported features, and cryptographic capabilities (OIDC Discovery §3).",
        from: "OpenID Provider",
        to: "Client",
        type: "response",
        parameters: {
          issuer: "OP identifier URL - MUST match ID Token 'iss' exactly (REQUIRED)",
          authorization_endpoint: "URL for authorization requests (REQUIRED)",
          token_endpoint: "URL for token exchange (REQUIRED unless implicit only)",
          userinfo_endpoint: "URL for UserInfo claims (RECOMMENDED)",
          jwks_uri: "URL for JSON Web Key Set (REQUIRED)",
          registration_endpoint: "URL for dynamic client registration (OPTIONAL)",
          scopes_supported: "Array of supported scope values (RECOMMENDED)",
          response_types_supported: "Array: code, id_token, token combinations (REQUIRED)",
          response_modes_supported: "Array: query, fragment, form_post (OPTIONAL)",
          grant_types_supported: "Array: authorization_code, implicit, refresh_token (OPTIONAL)",
          subject_types_supported: "Array: public, pairwise (REQUIRED)",
          id_token_signing_alg_values_supported: "Array: RS256, etc. (REQUIRED)",
          claims_supported: "Array of available claim names (RECOMMENDED)",
          code_challenge_methods_supported: "Array: S256, plain for PKCE (OPTIONAL)",
          revocation_endpoint: "URL for token revocation (RFC 7009)",
          introspection_endpoint: "URL for token introspection (RFC 7662)",
        },
        security: [
          "Verify 'issuer' matches expected OP identifier exactly",
          "Use scopes_supported to validate scope requests",
          "Check code_challenge_methods_supported for PKCE support",
          "Cache configuration with appropriate TTL (hours to days)",
        ],
      },
      {
        order: 3,
        name: "JWKS Request",
        description: "Client fetches the JSON Web Key Set (JWKS) from jwks_uri. Contains public keys for validating ID Token and UserInfo JWT signatures (RFC 7517).",
        from: "Client",
        to: "OpenID Provider",
        type: "request",
        parameters: {
          endpoint: "jwks_uri from discovery document",
          method: "GET",
          "Accept": "application/json",
        },
        security: [
          "Cache JWKS with appropriate TTL (hours)",
          "Implement key rotation handling - refetch on unknown 'kid'",
          "Multiple keys may be present for rotation support",
        ],
      },
      {
        order: 4,
        name: "JWKS Response",
        description: "Returns array of JSON Web Keys (JWKs) used for signing tokens. Match 'kid' (key ID) from token header to find correct verification key (RFC 7517 §5).",
        from: "OpenID Provider",
        to: "Client",
        type: "response",
        parameters: {
          keys: "Array of JWK objects",
          kty: "Key type: 'RSA' or 'EC' (REQUIRED)",
          use: "Key usage: 'sig' for signing (OPTIONAL but common)",
          alg: "Algorithm: 'RS256', 'ES256', etc. (OPTIONAL)",
          kid: "Key ID - matches 'kid' in token header (OPTIONAL but common)",
          n: "RSA public key modulus (Base64URL, for RSA keys)",
          e: "RSA public key exponent (Base64URL, typically 'AQAB')",
          x: "EC public key X coordinate (for EC keys)",
          y: "EC public key Y coordinate (for EC keys)",
          crv: "EC curve: 'P-256', 'P-384', 'P-521' (for EC keys)",
        },
        security: [
          "Match 'kid' from token to correct key in JWKS",
          "Multiple keys support key rotation without downtime",
          "Only keys with use='sig' or undefined are for signature verification",
          "Validate kty matches expected algorithm (RS256 → RSA, ES256 → EC)",
        ],
      },
      {
        order: 5,
        name: "Client Configuration",
        description: "Client stores discovered endpoints and keys for use in authentication flows. Implements caching and refresh strategy.",
        from: "Client",
        to: "Client",
        type: "internal",
        parameters: {
          cache: "Store configuration and JWKS with TTL",
          validate: "Verify all required endpoints are present",
          configure: "Set up OAuth/OIDC client with discovered endpoints",
        },
        security: [
          "Re-fetch JWKS if token has unknown 'kid'",
          "Periodically refresh discovery doc and JWKS",
          "Validate TLS certificates for all endpoints",
        ],
      },
    ]
  },

  // SAML 2.0 Flows
  saml_sp_initiated_sso: {
    title: "SP-Initiated SSO",
    description: "Service Provider initiates Single Sign-On by redirecting the user to the Identity Provider with an AuthnRequest.",
    steps: [
      {
        order: 1,
        name: "Access Protected Resource",
        description: "User attempts to access a protected resource at the Service Provider.",
        from: "User",
        to: "Service Provider",
        type: "request",
      },
      {
        order: 2,
        name: "Generate AuthnRequest",
        description: "SP creates a SAML AuthnRequest message to request authentication.",
        from: "Service Provider",
        to: "Service Provider",
        type: "internal",
        parameters: {
          ID: "Unique request identifier",
          IssueInstant: "Timestamp of request creation",
          Issuer: "SP Entity ID",
          AssertionConsumerServiceURL: "Where to send the response",
          ProtocolBinding: "HTTP-POST or HTTP-Redirect",
        },
      },
      {
        order: 3,
        name: "Redirect to IdP",
        description: "SP redirects user to IdP SSO Service with the AuthnRequest.",
        from: "Service Provider",
        to: "Identity Provider",
        type: "redirect",
        parameters: {
          SAMLRequest: "Base64-encoded (and deflated for redirect) AuthnRequest",
          RelayState: "Opaque state to be echoed back",
          SigAlg: "Signature algorithm (if signed)",
          Signature: "Request signature (if signed)",
        },
      },
      {
        order: 4,
        name: "User Authentication",
        description: "User authenticates at the Identity Provider.",
        from: "User",
        to: "Identity Provider",
        type: "internal",
      },
      {
        order: 5,
        name: "Generate SAML Response",
        description: "IdP creates a SAML Response containing the Assertion with user identity.",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          Status: "Success or error code",
          Assertion: "Signed assertion with user identity",
          NameID: "User identifier",
          Attributes: "User attributes (optional)",
          Conditions: "Validity constraints",
          AuthnStatement: "Authentication context",
        },
      },
      {
        order: 6,
        name: "POST Response to ACS",
        description: "IdP sends SAML Response to SP's Assertion Consumer Service.",
        from: "Identity Provider",
        to: "Service Provider",
        type: "response",
        parameters: {
          SAMLResponse: "Base64-encoded SAML Response",
          RelayState: "Echoed from request",
        },
      },
      {
        order: 7,
        name: "Validate Assertion",
        description: "SP validates the signature, conditions, and extracts identity.",
        from: "Service Provider",
        to: "Service Provider",
        type: "internal",
        parameters: {
          verify_signature: "Check Response/Assertion signature",
          check_inresponseto: "Must match original request ID",
          validate_conditions: "NotBefore/NotOnOrAfter timestamps",
          verify_audience: "SP Entity ID must be in audience",
          check_replay: "Assertion ID not previously used",
        },
      },
      {
        order: 8,
        name: "Create Session",
        description: "SP creates a local session and grants access to the resource.",
        from: "Service Provider",
        to: "User",
        type: "response",
      },
    ]
  },

  saml_idp_initiated_sso: {
    title: "IdP-Initiated SSO",
    description: "Identity Provider initiates Single Sign-On without a prior AuthnRequest. User starts at IdP and is sent to SP with an unsolicited SAML Response.",
    steps: [
      {
        order: 1,
        name: "User at IdP Portal",
        description: "User is authenticated at the IdP and selects an SP to access.",
        from: "User",
        to: "Identity Provider",
        type: "request",
      },
      {
        order: 2,
        name: "Generate Unsolicited Response",
        description: "IdP creates a SAML Response without a prior AuthnRequest.",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          InResponseTo: "Empty (no request to respond to)",
          Destination: "SP's ACS URL from metadata",
          note: "No InResponseTo to validate - increased replay risk",
        },
      },
      {
        order: 3,
        name: "POST Response to SP",
        description: "IdP POSTs the SAML Response to SP's Assertion Consumer Service.",
        from: "Identity Provider",
        to: "Service Provider",
        type: "response",
        parameters: {
          SAMLResponse: "Base64-encoded SAML Response with Assertion",
          RelayState: "Optional - target URL at SP",
        },
      },
      {
        order: 4,
        name: "Validate Assertion",
        description: "SP validates the response and extracts identity.",
        from: "Service Provider",
        to: "Service Provider",
        type: "internal",
        parameters: {
          verify_signature: "Check Assertion signature",
          validate_conditions: "Check time constraints",
          check_audience: "Verify SP is intended recipient",
          security_note: "Cannot verify InResponseTo - use other replay prevention",
        },
      },
      {
        order: 5,
        name: "Create Session",
        description: "SP creates a local session and grants access.",
        from: "Service Provider",
        to: "User",
        type: "response",
      },
    ]
  },

  saml_single_logout: {
    title: "Single Logout (SLO)",
    description: "Terminates all sessions established via SSO across all participating Service Providers and the Identity Provider.",
    steps: [
      {
        order: 1,
        name: "Initiate Logout",
        description: "User initiates logout at one participant (SP or IdP).",
        from: "User",
        to: "Service Provider",
        type: "request",
      },
      {
        order: 2,
        name: "Create LogoutRequest",
        description: "Initiating party creates a SAML LogoutRequest.",
        from: "Service Provider",
        to: "Service Provider",
        type: "internal",
        parameters: {
          NameID: "Identifier of user being logged out",
          SessionIndex: "Specific session to terminate (optional)",
          Reason: "Logout reason (optional)",
        },
      },
      {
        order: 3,
        name: "Send LogoutRequest to IdP",
        description: "SP sends LogoutRequest to IdP's SLO endpoint.",
        from: "Service Provider",
        to: "Identity Provider",
        type: "request",
        parameters: {
          SAMLRequest: "Base64-encoded LogoutRequest",
          RelayState: "State to maintain through logout",
        },
      },
      {
        order: 4,
        name: "Propagate to Other SPs",
        description: "IdP sends LogoutRequest to all other SPs with active sessions.",
        from: "Identity Provider",
        to: "Other Service Providers",
        type: "request",
        parameters: {
          note: "Each SP must validate and terminate their session",
        },
      },
      {
        order: 5,
        name: "SPs Respond",
        description: "Each SP terminates its session and sends LogoutResponse.",
        from: "Service Providers",
        to: "Identity Provider",
        type: "response",
        parameters: {
          Status: "Success or failure",
        },
      },
      {
        order: 6,
        name: "IdP Terminates Session",
        description: "IdP terminates its own session for the user.",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
      },
      {
        order: 7,
        name: "Final LogoutResponse",
        description: "IdP sends LogoutResponse to the initiating SP.",
        from: "Identity Provider",
        to: "Service Provider",
        type: "response",
        parameters: {
          Status: "Success or PartialLogout",
          InResponseTo: "Original LogoutRequest ID",
        },
      },
      {
        order: 8,
        name: "Logout Complete",
        description: "User is logged out of all participants.",
        from: "Service Provider",
        to: "User",
        type: "response",
      },
    ]
  },

  saml_metadata: {
    title: "Metadata Exchange",
    description: "Exchange of SAML metadata documents describing entity configurations, endpoints, certificates, and capabilities.",
    steps: [
      {
        order: 1,
        name: "Request SP Metadata",
        description: "Retrieve the Service Provider's metadata document.",
        from: "Identity Provider",
        to: "Service Provider",
        type: "request",
        parameters: {
          endpoint: "/saml/metadata",
          method: "GET",
        },
      },
      {
        order: 2,
        name: "SP Metadata Response",
        description: "SP returns its metadata XML document.",
        from: "Service Provider",
        to: "Identity Provider",
        type: "response",
        parameters: {
          entityID: "SP's unique identifier",
          AssertionConsumerService: "ACS URL and binding",
          SingleLogoutService: "SLO URL and binding",
          KeyDescriptor: "X.509 certificates for signing/encryption",
          NameIDFormat: "Supported name identifier formats",
        },
      },
      {
        order: 3,
        name: "Request IdP Metadata",
        description: "Retrieve the Identity Provider's metadata document.",
        from: "Service Provider",
        to: "Identity Provider",
        type: "request",
        parameters: {
          endpoint: "/saml/metadata",
          method: "GET",
        },
      },
      {
        order: 4,
        name: "IdP Metadata Response",
        description: "IdP returns its metadata XML document.",
        from: "Identity Provider",
        to: "Service Provider",
        type: "response",
        parameters: {
          entityID: "IdP's unique identifier",
          SingleSignOnService: "SSO URL and binding",
          SingleLogoutService: "SLO URL and binding",
          KeyDescriptor: "X.509 certificates for signing",
          NameIDFormat: "Supported name identifier formats",
        },
      },
      {
        order: 5,
        name: "Configure Trust",
        description: "Both parties import and configure the other's metadata.",
        from: "Both Parties",
        to: "Both Parties",
        type: "internal",
        parameters: {
          verify_signature: "Validate metadata signature if signed",
          store_certificates: "Cache certificates for validation",
          configure_endpoints: "Set up SSO/SLO URLs",
        },
      },
    ]
  },

  // ============================================================================
  // SPIFFE/SPIRE Flows
  // ============================================================================

  'x509-svid-issuance': {
    title: "X.509-SVID Acquisition",
    description: "Acquire an X.509 certificate containing a SPIFFE ID via the Workload API.",
    steps: [
      {
        order: 1,
        name: "Connect to Workload API",
        description: "Workload connects to SPIRE Agent via Unix Domain Socket.",
        from: "Workload",
        to: "SPIRE Agent",
        type: "request",
        parameters: {
          socket_path: "unix:///run/spire/sockets/agent.sock",
          protocol: "gRPC",
          api_method: "FetchX509SVID (streaming)",
        },
      },
      {
        order: 2,
        name: "Workload Attestation",
        description: "Agent verifies the calling workload's identity using selectors.",
        from: "SPIRE Agent",
        to: "Workload Attestor",
        type: "internal",
        parameters: {
          unix_selectors: "uid, gid, binary path",
          docker_selectors: "container labels, image ID",
          k8s_selectors: "namespace, service account, pod labels",
        },
      },
      {
        order: 3,
        name: "SVID Request",
        description: "Agent requests SVID from SPIRE Server on workload's behalf.",
        from: "SPIRE Agent",
        to: "SPIRE Server",
        type: "request",
        parameters: {
          spiffe_id: "From registration entry",
          csr: "Certificate Signing Request",
          ttl_hint: "Requested TTL",
        },
      },
      {
        order: 4,
        name: "Certificate Signing",
        description: "Server signs the certificate with the trust domain CA.",
        from: "SPIRE Server",
        to: "CA",
        type: "internal",
        parameters: {
          issuer: "Trust domain CA",
          san_uri: "spiffe://trust-domain/workload/path",
          validity: "Short-lived (typically 1 hour)",
        },
      },
      {
        order: 5,
        name: "SVID Delivery",
        description: "X.509-SVID delivered to workload with private key.",
        from: "SPIRE Agent",
        to: "Workload",
        type: "response",
        parameters: {
          x509_svid: "Signed X.509 certificate",
          private_key: "Corresponding private key",
          trust_bundle: "CA certificates for verification",
        },
      },
    ]
  },

  'jwt-svid-issuance': {
    title: "JWT-SVID Acquisition",
    description: "Acquire a JWT token containing SPIFFE claims for API authentication.",
    steps: [
      {
        order: 1,
        name: "Request JWT-SVID",
        description: "Workload requests JWT-SVID with target audience.",
        from: "Workload",
        to: "SPIRE Agent",
        type: "request",
        parameters: {
          api_method: "FetchJWTSVID",
          audience: "Intended recipient (e.g., api.example.com)",
        },
      },
      {
        order: 2,
        name: "Identity Verification",
        description: "Agent verifies workload is authorized for this SPIFFE ID.",
        from: "SPIRE Agent",
        to: "Registration Cache",
        type: "internal",
        parameters: {
          selector_match: "Verify workload selectors match entry",
          spiffe_id: "Assigned from matching entry",
        },
      },
      {
        order: 3,
        name: "JWT Generation",
        description: "Server generates and signs JWT with SPIFFE claims.",
        from: "SPIRE Server",
        to: "JWT Signer",
        type: "internal",
        parameters: {
          alg: "ES256 or RS256",
          sub: "SPIFFE ID (spiffe://trust-domain/path)",
          aud: "Target audience(s)",
          exp: "Short expiration (typically 5 minutes)",
          iat: "Issued at timestamp",
        },
      },
      {
        order: 4,
        name: "Token Delivery",
        description: "JWT-SVID returned to workload for API authentication.",
        from: "SPIRE Agent",
        to: "Workload",
        type: "response",
        parameters: {
          token: "Signed JWT-SVID",
          expiry: "Token expiration time",
        },
      },
    ]
  },

  'mtls-handshake': {
    title: "mTLS with X.509-SVIDs",
    description: "Establish mutual TLS authentication between services using SPIFFE identities.",
    steps: [
      {
        order: 1,
        name: "Client Fetches SVID",
        description: "Client service obtains its X.509-SVID from Workload API.",
        from: "Client",
        to: "SPIRE Agent",
        type: "request",
        parameters: {
          x509_svid: "Client's certificate",
          private_key: "Client's private key",
          trust_bundle: "CA certificates",
        },
      },
      {
        order: 2,
        name: "TLS Client Hello",
        description: "Client initiates TLS connection to server.",
        from: "Client",
        to: "Server",
        type: "request",
        parameters: {
          tls_version: "TLS 1.2 or 1.3",
          cipher_suites: "Supported algorithms",
        },
      },
      {
        order: 3,
        name: "Server Certificate",
        description: "Server presents its X.509-SVID certificate.",
        from: "Server",
        to: "Client",
        type: "response",
        parameters: {
          certificate: "Server's X.509-SVID",
          san_uri: "spiffe://trust-domain/server",
        },
      },
      {
        order: 4,
        name: "Client Certificate",
        description: "Client presents its X.509-SVID certificate.",
        from: "Client",
        to: "Server",
        type: "response",
        parameters: {
          certificate: "Client's X.509-SVID",
          san_uri: "spiffe://trust-domain/client",
        },
      },
      {
        order: 5,
        name: "Mutual Verification",
        description: "Both sides verify certificates against SPIFFE trust bundle.",
        from: "Both",
        to: "Trust Bundle",
        type: "internal",
        parameters: {
          chain_validation: "Verify to trusted root",
          spiffe_id_check: "Extract and authorize SPIFFE ID",
        },
      },
      {
        order: 6,
        name: "Secure Channel",
        description: "Encrypted channel established with verified identities.",
        from: "Client",
        to: "Server",
        type: "internal",
        parameters: {
          client_id: "spiffe://trust-domain/client",
          server_id: "spiffe://trust-domain/server",
          encryption: "TLS 1.3 with forward secrecy",
        },
      },
    ]
  },

  'certificate-rotation': {
    title: "Certificate Rotation",
    description: "Automatic X.509-SVID rotation without service disruption.",
    steps: [
      {
        order: 1,
        name: "Monitor Expiration",
        description: "SPIRE Agent monitors certificate lifetime.",
        from: "SPIRE Agent",
        to: "SVID Cache",
        type: "internal",
        parameters: {
          check_interval: "Periodic (e.g., every 30s)",
          rotation_threshold: "Typically 50% of TTL",
        },
      },
      {
        order: 2,
        name: "Pre-Rotation Request",
        description: "Agent requests new SVID before expiration.",
        from: "SPIRE Agent",
        to: "SPIRE Server",
        type: "request",
        parameters: {
          reason: "Approaching rotation threshold",
          current_serial: "For tracking",
        },
      },
      {
        order: 3,
        name: "New SVID Issued",
        description: "Server issues fresh certificate with new validity period.",
        from: "SPIRE Server",
        to: "SPIRE Agent",
        type: "response",
        parameters: {
          new_x509_svid: "Fresh certificate",
          new_serial: "New serial number",
          validity: "Fresh TTL period",
        },
      },
      {
        order: 4,
        name: "Workload Notification",
        description: "Workload receives new SVID via streaming API.",
        from: "SPIRE Agent",
        to: "Workload",
        type: "response",
        parameters: {
          streaming_update: "FetchX509SVID stream delivers new SVID",
          trust_bundle: "Updated if changed",
        },
      },
      {
        order: 5,
        name: "Graceful Transition",
        description: "Workload uses new certificate for new connections.",
        from: "Workload",
        to: "TLS Stack",
        type: "internal",
        parameters: {
          new_connections: "Use new certificate",
          existing_connections: "Continue with old cert until closed",
          zero_downtime: "No service interruption",
        },
      },
    ]
  },

  // ============================================================================
  // SCIM 2.0 Flows (RFC 7642, 7643, 7644)
  // ============================================================================

  'scim_user_lifecycle': {
    title: "User Lifecycle Management",
    description: "Complete CRUD operations for user resources. Enables IdPs like Okta and Azure AD to provision, update, and deprovision users automatically.",
    steps: [
      {
        order: 1,
        name: "Check User Exists",
        description: "IdP queries for existing user by email/userName before creating.",
        from: "Identity Provider",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "GET",
          endpoint: '/Users?filter=userName eq "user@example.com"',
          Authorization: "Bearer {api_token}",
          Accept: "application/scim+json",
        },
      },
      {
        order: 2,
        name: "Filter Response",
        description: "Server returns matching users (empty if none found).",
        from: "SCIM Server",
        to: "Identity Provider",
        type: "response",
        parameters: {
          totalResults: "0 if new user, 1+ if exists",
          Resources: "Array of matching User objects",
          schemas: "urn:ietf:params:scim:api:messages:2.0:ListResponse",
        },
      },
      {
        order: 3,
        name: "Create User",
        description: "IdP creates new user if not found (POST) or updates if exists (PUT/PATCH).",
        from: "Identity Provider",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "POST /Users (create) or PATCH /Users/{id} (update)",
          schemas: "urn:ietf:params:scim:schemas:core:2.0:User",
          userName: "Unique identifier (often email)",
          name: "{ givenName, familyName }",
          emails: "[{ value, type, primary }]",
          active: "true/false for account status",
        },
      },
      {
        order: 4,
        name: "User Created",
        description: "Server returns created/updated user with server-assigned id and meta.",
        from: "SCIM Server",
        to: "Identity Provider",
        type: "response",
        parameters: {
          id: "Server-assigned unique identifier",
          meta: "{ resourceType, created, lastModified, version }",
          Location: "Full URL to resource in header",
          ETag: "Version identifier for optimistic locking",
        },
      },
      {
        order: 5,
        name: "Deactivate User",
        description: "IdP deactivates user when removed from assignment (PATCH active=false).",
        from: "Identity Provider",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "PATCH /Users/{id}",
          Operations: '[{ "op": "replace", "path": "active", "value": false }]',
          schemas: "urn:ietf:params:scim:api:messages:2.0:PatchOp",
        },
      },
      {
        order: 6,
        name: "User Deactivated",
        description: "Server confirms user deactivation.",
        from: "SCIM Server",
        to: "Identity Provider",
        type: "response",
        parameters: {
          active: "false",
          meta: "Updated lastModified timestamp",
        },
      },
    ]
  },

  'scim_group_management': {
    title: "Group Management",
    description: "Manage groups and their memberships. Enables automatic group sync between IdP and service provider for access control.",
    steps: [
      {
        order: 1,
        name: "Create Group",
        description: "IdP creates a group in the service provider.",
        from: "Identity Provider",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "POST /Groups",
          schemas: "urn:ietf:params:scim:schemas:core:2.0:Group",
          displayName: "Group name",
          members: "Initial members (optional)",
        },
      },
      {
        order: 2,
        name: "Group Created",
        description: "Server returns created group with id.",
        from: "SCIM Server",
        to: "Identity Provider",
        type: "response",
        parameters: {
          id: "Server-assigned group ID",
          displayName: "Group name",
          meta: "{ resourceType: 'Group', created, lastModified }",
        },
      },
      {
        order: 3,
        name: "Add Member",
        description: "IdP adds a user to the group.",
        from: "Identity Provider",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "PATCH /Groups/{id}",
          Operations: '[{ "op": "add", "path": "members", "value": [{ "value": "{userId}" }] }]',
        },
      },
      {
        order: 4,
        name: "Member Added",
        description: "Server confirms membership addition.",
        from: "SCIM Server",
        to: "Identity Provider",
        type: "response",
        parameters: {
          members: "Updated member list",
          meta: "Updated lastModified",
        },
      },
      {
        order: 5,
        name: "Remove Member",
        description: "IdP removes a user from the group.",
        from: "Identity Provider",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "PATCH /Groups/{id}",
          Operations: '[{ "op": "remove", "path": "members[value eq \\"{userId}\\"]" }]',
        },
      },
      {
        order: 6,
        name: "Member Removed",
        description: "Server confirms membership removal.",
        from: "SCIM Server",
        to: "Identity Provider",
        type: "response",
        parameters: {
          members: "Updated member list without removed user",
        },
      },
    ]
  },

  'scim_filter_queries': {
    title: "Filter Queries",
    description: "RFC 7644 compliant filter syntax for querying SCIM resources. Supports comparison, logical, and grouping operators.",
    steps: [
      {
        order: 1,
        name: "Simple Filter",
        description: "Query using basic attribute comparison.",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "GET",
          endpoint: '/Users?filter=userName eq "john@example.com"',
          operators: "eq, ne, co, sw, ew, gt, lt, ge, le, pr",
        },
      },
      {
        order: 2,
        name: "Filter Results",
        description: "Server returns matching resources in ListResponse.",
        from: "SCIM Server",
        to: "Client",
        type: "response",
        parameters: {
          totalResults: "Total matching resources",
          Resources: "Array of matching resources",
          startIndex: "1-based pagination start",
          itemsPerPage: "Number of results returned",
        },
      },
      {
        order: 3,
        name: "Complex Filter",
        description: "Query using logical operators and nested attributes.",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          endpoint: '/Users?filter=emails[type eq "work" and primary eq true]',
          logical: "and, or, not",
          grouping: "Parentheses for precedence",
          nested: "attribute[sub-attribute op value]",
        },
      },
      {
        order: 4,
        name: "Paginated Results",
        description: "Server returns paginated results for large datasets.",
        from: "SCIM Server",
        to: "Client",
        type: "response",
        parameters: {
          startIndex: "Requested start position",
          itemsPerPage: "Actual count returned",
          totalResults: "Total matching (may require count param)",
        },
      },
      {
        order: 5,
        name: "Sorted Results",
        description: "Request results sorted by attribute.",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          sortBy: "Attribute to sort by",
          sortOrder: "ascending (default) or descending",
          endpoint: "/Users?sortBy=name.familyName&sortOrder=descending",
        },
      },
    ]
  },

  'scim_schema_discovery': {
    title: "Schema Discovery",
    description: "Discover SCIM server capabilities, supported schemas, and resource types. Essential for client auto-configuration.",
    steps: [
      {
        order: 1,
        name: "Get ServiceProviderConfig",
        description: "Discover server capabilities and supported features.",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "GET /ServiceProviderConfig",
          purpose: "Discover supported features",
        },
      },
      {
        order: 2,
        name: "Server Capabilities",
        description: "Server returns its configuration and supported features.",
        from: "SCIM Server",
        to: "Client",
        type: "response",
        parameters: {
          patch: "{ supported: true/false }",
          bulk: "{ supported, maxOperations, maxPayloadSize }",
          filter: "{ supported, maxResults }",
          changePassword: "{ supported: true/false }",
          sort: "{ supported: true/false }",
          etag: "{ supported: true/false }",
          authenticationSchemes: "Supported auth methods",
        },
      },
      {
        order: 3,
        name: "Get Resource Types",
        description: "Discover available resource types (User, Group, etc.).",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "GET /ResourceTypes",
          purpose: "List available resource types",
        },
      },
      {
        order: 4,
        name: "Resource Types List",
        description: "Server returns supported resource types with their schemas.",
        from: "SCIM Server",
        to: "Client",
        type: "response",
        parameters: {
          id: "User, Group, etc.",
          name: "Human-readable name",
          endpoint: "Resource endpoint path",
          schema: "Core schema URN",
          schemaExtensions: "Optional extension schemas",
        },
      },
      {
        order: 5,
        name: "Get Schemas",
        description: "Fetch detailed schema definitions.",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "GET /Schemas",
          or: "GET /Schemas/{schema-urn}",
        },
      },
      {
        order: 6,
        name: "Schema Definitions",
        description: "Server returns complete attribute definitions.",
        from: "SCIM Server",
        to: "Client",
        type: "response",
        parameters: {
          attributes: "Array of attribute definitions",
          name: "Attribute name",
          type: "string, boolean, complex, etc.",
          multiValued: "true/false",
          required: "true/false",
          mutability: "readWrite, readOnly, immutable, writeOnly",
        },
      },
    ]
  },

  'scim_bulk_operations': {
    title: "Bulk Operations",
    description: "Execute multiple SCIM operations in a single request. Efficient for batch provisioning and large-scale changes.",
    steps: [
      {
        order: 1,
        name: "Check Bulk Support",
        description: "Verify server supports bulk operations and limits.",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "GET /ServiceProviderConfig",
          check: "bulk.supported, bulk.maxOperations, bulk.maxPayloadSize",
        },
      },
      {
        order: 2,
        name: "Bulk Capabilities",
        description: "Server returns bulk operation limits.",
        from: "SCIM Server",
        to: "Client",
        type: "response",
        parameters: {
          "bulk.supported": "true",
          "bulk.maxOperations": "Maximum operations per request",
          "bulk.maxPayloadSize": "Maximum request size in bytes",
        },
      },
      {
        order: 3,
        name: "Bulk Request",
        description: "Submit multiple operations in single request.",
        from: "Client",
        to: "SCIM Server",
        type: "request",
        parameters: {
          method: "POST /Bulk",
          schemas: "urn:ietf:params:scim:api:messages:2.0:BulkRequest",
          Operations: "Array of { method, path, bulkId, data }",
          failOnErrors: "Stop after N errors (optional)",
        },
      },
      {
        order: 4,
        name: "Process Operations",
        description: "Server processes each operation in order.",
        from: "SCIM Server",
        to: "SCIM Server",
        type: "internal",
        parameters: {
          order: "Operations processed sequentially",
          bulkId: "Allows cross-referencing created resources",
          atomicity: "Not guaranteed - partial success possible",
        },
      },
      {
        order: 5,
        name: "Bulk Response",
        description: "Server returns results for each operation.",
        from: "SCIM Server",
        to: "Client",
        type: "response",
        parameters: {
          schemas: "urn:ietf:params:scim:api:messages:2.0:BulkResponse",
          Operations: "Array of { method, bulkId, status, location, response }",
          status: "HTTP status code for each operation",
        },
      },
    ]
  },

  // ============================================================================
  // Shared Signals Framework (SSF) - RFC 8417, SSF 1.0, CAEP, RISC
  // ============================================================================

  'ssf_stream_configuration': {
    title: "Stream Configuration",
    description: "Configure an SSF stream between a Transmitter (IdP) and Receiver (RP). Defines which event types to share, delivery methods, and subject formats. The stream is the foundation of all SSF event sharing.",
    steps: [
      {
        order: 1,
        name: "Fetch Transmitter Configuration",
        description: "Receiver discovers the Transmitter's SSF capabilities via the well-known configuration endpoint (SSF §3.1). Similar to OIDC Discovery.",
        from: "Receiver",
        to: "Transmitter",
        type: "request",
        parameters: {
          method: "GET",
          endpoint: "/.well-known/ssf-configuration",
          Accept: "application/json",
        },
        security: [
          "HTTPS required - configuration contains security-critical endpoints",
          "Verify issuer matches expected Transmitter",
          "Cache configuration with appropriate TTL",
        ],
      },
      {
        order: 2,
        name: "SSF Configuration Response",
        description: "Transmitter returns its SSF metadata including supported event types, delivery methods, and endpoints for stream management.",
        from: "Transmitter",
        to: "Receiver",
        type: "response",
        parameters: {
          issuer: "Transmitter identifier URL (REQUIRED)",
          jwks_uri: "URL for SET signature verification keys",
          delivery_methods_supported: "['urn:ietf:rfc:8935', 'urn:ietf:rfc:8936']",
          configuration_endpoint: "URL to create/manage streams",
          status_endpoint: "URL to query stream status",
          add_subject_endpoint: "URL to add subjects to stream",
          remove_subject_endpoint: "URL to remove subjects",
          verification_endpoint: "URL for verification events (optional)",
        },
        security: [
          "Verify issuer matches expected Transmitter identity",
          "Validate jwks_uri is under Transmitter's domain",
          "Use only supported delivery methods",
        ],
      },
      {
        order: 3,
        name: "Create Stream Request",
        description: "Receiver creates a new event stream by specifying desired configuration. This establishes the bi-directional relationship for event sharing.",
        from: "Receiver",
        to: "Transmitter",
        type: "request",
        parameters: {
          method: "POST to configuration_endpoint",
          Authorization: "Bearer {management_token}",
          delivery: "{ method: 'urn:ietf:rfc:8935', endpoint_url: 'https://receiver/ssf/push' }",
          events_requested: "Array of event type URIs to subscribe to",
          format: "Subject identifier format (email, iss_sub, etc.)",
        },
        security: [
          "Management token must have stream creation permissions",
          "Validate endpoint_url is under Receiver's control",
          "Only request events your application can handle",
        ],
      },
      {
        order: 4,
        name: "Stream Created Response",
        description: "Transmitter creates the stream and returns its configuration including stream_id and the events that will actually be delivered.",
        from: "Transmitter",
        to: "Receiver",
        type: "response",
        parameters: {
          stream_id: "Unique identifier for this stream",
          iss: "Transmitter issuer URL",
          aud: "Receiver identifier (audience for SETs)",
          events_supported: "Event types the Transmitter can send",
          events_delivered: "Event types that will be delivered to this stream",
          delivery: "{ method, endpoint_url, status }",
          format: "Subject identifier format for this stream",
        },
        security: [
          "Store stream_id securely for future management operations",
          "Verify events_delivered matches your requirements",
          "Note: events_delivered may be subset of events_requested",
        ],
      },
      {
        order: 5,
        name: "Fetch JWKS",
        description: "Receiver fetches the Transmitter's JSON Web Key Set for SET signature verification. Keys are identified by 'kid' in SET headers.",
        from: "Receiver",
        to: "Transmitter",
        type: "request",
        parameters: {
          method: "GET",
          endpoint: "jwks_uri from configuration",
          Accept: "application/json",
        },
        security: [
          "Cache JWKS with appropriate TTL (hours)",
          "Implement key rotation handling - refetch on unknown kid",
          "Verify keys are suitable for SET signature verification",
        ],
      },
      {
        order: 6,
        name: "JWKS Response",
        description: "Transmitter returns its public keys for verifying SET signatures. SETs are always signed JWTs (RFC 8417).",
        from: "Transmitter",
        to: "Receiver",
        type: "response",
        parameters: {
          keys: "Array of JWK objects",
          kty: "Key type: RSA or EC",
          use: "sig (for signature verification)",
          alg: "Algorithm: RS256, ES256, etc.",
          kid: "Key ID - matches 'kid' in SET header",
        },
        security: [
          "Match 'kid' from SET to correct verification key",
          "Support multiple keys for rotation",
          "Only use keys with use='sig' or undefined",
        ],
      },
    ]
  },

  'ssf_push_delivery': {
    title: "Push Delivery Method",
    description: "Real-time event delivery where the Transmitter POSTs Security Event Tokens (SETs) directly to the Receiver's endpoint (RFC 8935). Provides immediate notification for time-sensitive security events.",
    steps: [
      {
        order: 1,
        name: "Security Event Occurs",
        description: "A security-relevant event occurs at the Transmitter (IdP) - such as session revocation, credential change, or account status change.",
        from: "Transmitter",
        to: "Transmitter",
        type: "internal",
        parameters: {
          event_source: "User action, admin action, policy, or system",
          subject: "Affected user/entity identifier",
          event_type: "CAEP or RISC event URI",
          timestamp: "When the event occurred",
        },
        security: [
          "Event triggers must be authenticated and authorized",
          "Log all event origins for audit trail",
          "Rate limit event generation to prevent abuse",
        ],
      },
      {
        order: 2,
        name: "Generate SET",
        description: "Transmitter creates a Security Event Token (SET) - a signed JWT containing the event data (RFC 8417). The SET is cryptographically bound to the Transmitter.",
        from: "Transmitter",
        to: "Transmitter",
        type: "internal",
        parameters: {
          iss: "Transmitter issuer URL (REQUIRED)",
          aud: "Receiver identifier (REQUIRED)",
          iat: "Issued-at timestamp (REQUIRED)",
          jti: "Unique token identifier (REQUIRED)",
          sub_id: "Subject identifier { format, email/iss_sub/etc }",
          events: "Object containing event type URI and payload",
          txn: "Transaction ID for correlation (optional)",
        },
        security: [
          "jti MUST be unique - enables replay detection",
          "Sign with RS256 or ES256 (never HMAC for cross-org)",
          "Include minimal necessary claims - principle of least privilege",
        ],
      },
      {
        order: 3,
        name: "Sign SET",
        description: "Transmitter signs the SET using its private key. The signature proves the SET originated from the legitimate Transmitter and hasn't been tampered with.",
        from: "Transmitter",
        to: "Transmitter",
        type: "internal",
        parameters: {
          alg: "RS256 or ES256 (asymmetric required)",
          kid: "Key ID matching JWKS entry",
          signature: "RSASSA-PKCS1-v1_5 or ECDSA signature",
        },
        security: [
          "Private key must be securely stored (HSM recommended)",
          "Include kid header for key identification",
          "Rotate signing keys periodically",
        ],
      },
      {
        order: 4,
        name: "Push Delivery Request",
        description: "Transmitter POSTs the SET to the Receiver's push endpoint (RFC 8935 §2). The SET is the request body with application/secevent+jwt content type.",
        from: "Transmitter",
        to: "Receiver",
        type: "request",
        parameters: {
          method: "POST",
          endpoint: "Receiver's push endpoint from stream config",
          "Content-Type": "application/secevent+jwt",
          Accept: "application/json",
          body: "The signed SET (compact JWT format)",
        },
        security: [
          "HTTPS required - SET contains sensitive event data",
          "May include Authorization header if configured",
          "Implement retry with exponential backoff",
          "Log delivery attempts for debugging",
        ],
      },
      {
        order: 5,
        name: "Receiver Validates SET",
        description: "Receiver validates the SET before processing: verify signature, check claims, detect replay. Invalid SETs are rejected.",
        from: "Receiver",
        to: "Receiver",
        type: "internal",
        parameters: {
          signature: "Verify using Transmitter's JWKS (match kid)",
          iss: "MUST match expected Transmitter",
          aud: "MUST include this Receiver's identifier",
          iat: "MUST be recent (within clock skew tolerance)",
          jti: "MUST NOT have been seen before (replay check)",
          events: "MUST contain recognized event type",
        },
        security: [
          "NEVER skip signature verification",
          "Store jti values for replay detection (with TTL)",
          "Reject SETs with unrecognized issuers",
          "Log validation failures for security monitoring",
        ],
      },
      {
        order: 6,
        name: "Process Event",
        description: "Receiver processes the validated event and takes appropriate action based on the event type. This may involve session termination, access revocation, or alerting.",
        from: "Receiver",
        to: "Receiver",
        type: "internal",
        parameters: {
          session_revoked: "Terminate affected user sessions",
          credential_change: "Invalidate cached credentials/tokens",
          account_disabled: "Block access for affected user",
          device_compliance: "Re-evaluate device access policies",
        },
        security: [
          "Execute response actions atomically",
          "Log all actions taken for audit",
          "Consider eventual consistency in distributed systems",
        ],
      },
      {
        order: 7,
        name: "Acknowledgment Response",
        description: "Receiver acknowledges receipt with HTTP 202 Accepted. Errors are reported via HTTP status codes and error response body.",
        from: "Receiver",
        to: "Transmitter",
        type: "response",
        parameters: {
          "202 Accepted": "SET received and will be processed",
          "400 Bad Request": "Invalid SET format or structure",
          "401 Unauthorized": "Authentication required/failed",
          "403 Forbidden": "Not authorized for this stream",
          "404 Not Found": "Subject not recognized",
        },
        security: [
          "202 indicates receipt, not necessarily processing complete",
          "Error responses should not leak sensitive information",
          "Rate limit error responses to prevent enumeration",
        ],
      },
    ]
  },

  'ssf_poll_delivery': {
    title: "Poll Delivery Method",
    description: "Receiver-initiated event retrieval where the Receiver periodically polls the Transmitter for pending events (RFC 8936). Useful when Receiver cannot expose public endpoints or for firewall-restricted environments.",
    steps: [
      {
        order: 1,
        name: "Poll Request",
        description: "Receiver sends a poll request to retrieve pending SETs. Can request events since last acknowledgment or with specific filters.",
        from: "Receiver",
        to: "Transmitter",
        type: "request",
        parameters: {
          method: "POST",
          endpoint: "/ssf/poll (from stream config)",
          "Content-Type": "application/json",
          Authorization: "Bearer {access_token}",
          maxEvents: "Maximum events to return (optional)",
          returnImmediately: "false for long-polling (optional)",
          acks: "Array of jti values to acknowledge",
        },
        security: [
          "Authentication required - Bearer token or mTLS",
          "Limit maxEvents to prevent response overflow",
          "Include acks to prevent re-delivery of processed events",
        ],
      },
      {
        order: 2,
        name: "Poll Response with SETs",
        description: "Transmitter returns pending SETs and indicates if more events are available. Each SET must be individually validated by the Receiver.",
        from: "Transmitter",
        to: "Receiver",
        type: "response",
        parameters: {
          sets: "Object mapping jti to SET (JWT string)",
          moreAvailable: "true if additional events pending",
          "Content-Type": "application/json",
        },
        security: [
          "Each SET in response must be validated independently",
          "moreAvailable=true requires follow-up poll",
          "Empty sets object means no pending events",
        ],
      },
      {
        order: 3,
        name: "Validate Each SET",
        description: "Receiver validates each SET in the response: signature verification, claim validation, and replay detection.",
        from: "Receiver",
        to: "Receiver",
        type: "internal",
        parameters: {
          per_set: "Same validation as push delivery",
          signature: "Verify using Transmitter's JWKS",
          jti: "Track for acknowledgment",
          events: "Extract and process event payload",
        },
        security: [
          "Process SETs in order if event order matters",
          "Failed validation should not block other SETs",
          "Log validation failures for debugging",
        ],
      },
      {
        order: 4,
        name: "Process Events",
        description: "Receiver processes all validated events and executes appropriate response actions for each event type.",
        from: "Receiver",
        to: "Receiver",
        type: "internal",
        parameters: {
          batch: "May process multiple events in single poll",
          ordering: "Consider event timestamps for ordering",
          idempotency: "Handle potential duplicate processing",
        },
        security: [
          "Process events idempotently",
          "Log all actions for audit trail",
          "Consider transaction boundaries",
        ],
      },
      {
        order: 5,
        name: "Acknowledge Events",
        description: "Receiver acknowledges processed events in the next poll request. Acknowledged events won't be re-delivered.",
        from: "Receiver",
        to: "Transmitter",
        type: "request",
        parameters: {
          acks: "Array of jti values successfully processed",
          setErrs: "Object mapping jti to error for failed SETs",
          error: "Error code: invalid_request, access_denied, etc.",
          description: "Human-readable error description",
        },
        security: [
          "Only acknowledge after successful processing",
          "Report setErrs for invalid SETs",
          "Transmitter may retry unacknowledged events",
        ],
      },
    ]
  },

  'caep_session_revoked': {
    title: "Session Revoked Event (CAEP)",
    description: "Continuous Access Evaluation Profile event indicating a user session has been terminated. Receiving systems must immediately invalidate the affected session to maintain zero-trust posture (CAEP §3.1).",
    steps: [
      {
        order: 1,
        name: "Session Revocation Trigger",
        description: "An event triggers session revocation at the IdP: user logout, admin action, security policy, or suspicious activity detection.",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          triggers: "User logout, admin revoke, policy violation, risk signal",
          scope: "Single session (session_id) or all sessions",
          reason: "Logout, policy, security, admin action",
        },
        security: [
          "Validate authorization to revoke sessions",
          "Log revocation reason for audit",
          "Consider notification to affected user",
        ],
      },
      {
        order: 2,
        name: "Create Session Revoked SET",
        description: "IdP creates a Security Event Token for the session-revoked event type (CAEP §3.1).",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          event_type: "https://schemas.openid.net/secevent/caep/event-type/session-revoked",
          sub_id: "Subject identifier (email, iss_sub, etc.)",
          event_timestamp: "When session was revoked",
          initiating_entity: "admin | user | policy | system",
          reason_admin: "Admin-facing reason { en: 'description' }",
          reason_user: "User-facing reason { en: 'description' }",
        },
        security: [
          "Include sufficient context for Receiver to act",
          "reason_admin may contain sensitive details",
          "reason_user should be safe to display to end users",
        ],
      },
      {
        order: 3,
        name: "Deliver SET to Receivers",
        description: "Transmitter sends the SET to all subscribed Receivers via their configured delivery method (push or poll).",
        from: "Transmitter",
        to: "All Subscribed Receivers",
        type: "request",
        parameters: {
          delivery: "Push (POST to endpoint) or Poll (queue for retrieval)",
          "Content-Type": "application/secevent+jwt",
          audience: "Specific to each Receiver's stream configuration",
        },
        security: [
          "Deliver to all active streams for this subject",
          "Each Receiver gets SET with their aud claim",
          "Retry failed deliveries with backoff",
        ],
      },
      {
        order: 4,
        name: "Receiver Validates SET",
        description: "Receiver validates the SET signature and claims before processing the session revocation.",
        from: "Receiver (RP)",
        to: "Receiver (RP)",
        type: "internal",
        parameters: {
          signature: "Verify against Transmitter's JWKS",
          event_type: "Must be session-revoked",
          iss: "Must match expected Transmitter",
          aud: "Must include this Receiver",
          jti: "Must not be replayed",
        },
        security: [
          "Reject SETs failing any validation step",
          "Log all validation failures",
          "Consider timing of event_timestamp",
        ],
      },
      {
        order: 5,
        name: "Terminate User Sessions",
        description: "Receiver immediately terminates all sessions for the affected subject. User must re-authenticate to continue.",
        from: "Receiver (RP)",
        to: "Session Store",
        type: "internal",
        parameters: {
          action: "Delete/invalidate all sessions for subject",
          lookup: "Find sessions by sub_id",
          invalidate: "Mark sessions as revoked",
          effect: "User immediately logged out",
        },
        security: [
          "Execute immediately for security events",
          "Consider graceful session termination for UX",
          "Log termination for audit trail",
        ],
      },
      {
        order: 6,
        name: "Revoke Access Tokens",
        description: "Receiver invalidates any cached or issued access tokens for the affected subject to prevent continued API access.",
        from: "Receiver (RP)",
        to: "Token Store",
        type: "internal",
        parameters: {
          access_tokens: "Revoke all active access tokens",
          refresh_tokens: "Revoke refresh tokens",
          api_keys: "Consider API key revocation",
        },
        security: [
          "Token revocation is critical for zero-trust",
          "Propagate to all services if distributed",
          "Consider token blacklist for JWT validation",
        ],
      },
    ]
  },

  'caep_credential_change': {
    title: "Credential Change Event (CAEP)",
    description: "Event indicating a user's credentials have changed (password, MFA, passkey). Receiving systems should force re-authentication and may need to refresh cached identity data (CAEP §3.2).",
    steps: [
      {
        order: 1,
        name: "Credential Change Occurs",
        description: "User or admin changes credentials at the Identity Provider. This includes password changes, MFA enrollment/removal, and passkey updates.",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          credential_type: "password | pin | x509 | fido2-platform | otp",
          change_type: "create | revoke | update",
          initiating_entity: "user | admin | system",
        },
        security: [
          "Credential changes must be authenticated",
          "Log credential change for security audit",
          "Consider step-up auth for sensitive changes",
        ],
      },
      {
        order: 2,
        name: "Create Credential Change SET",
        description: "IdP creates a Security Event Token for the credential-change event type (CAEP §3.2).",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          event_type: "https://schemas.openid.net/secevent/caep/event-type/credential-change",
          sub_id: "Subject identifier",
          credential_type: "Type of credential changed",
          change_type: "create | revoke | update",
          event_timestamp: "When change occurred",
          initiating_entity: "admin | user | policy | system",
          reason_admin: "Admin-facing reason",
        },
        security: [
          "Do not include actual credential values",
          "Include credential_type for context",
          "change_type helps Receivers determine action",
        ],
      },
      {
        order: 3,
        name: "Deliver SET to Receivers",
        description: "Transmitter sends the credential change event to all subscribed Receivers.",
        from: "Transmitter",
        to: "All Subscribed Receivers",
        type: "request",
        parameters: {
          delivery: "Push or Poll",
          event: "credential-change SET",
        },
      },
      {
        order: 4,
        name: "Receiver Validates SET",
        description: "Receiver validates the SET before processing.",
        from: "Receiver (RP)",
        to: "Receiver (RP)",
        type: "internal",
        parameters: {
          signature: "Verify against JWKS",
          claims: "Validate iss, aud, iat, jti",
        },
      },
      {
        order: 5,
        name: "Invalidate Cached Credentials",
        description: "Receiver invalidates any cached credential data and tokens derived from previous credentials.",
        from: "Receiver (RP)",
        to: "Credential Cache",
        type: "internal",
        parameters: {
          cached_tokens: "Invalidate tokens from old credentials",
          cached_claims: "Clear cached identity claims",
          derived_keys: "Revoke keys derived from credentials",
        },
        security: [
          "Credential changes may indicate compromise",
          "Conservative approach: revoke all tokens",
          "Consider credential_type for targeted action",
        ],
      },
      {
        order: 6,
        name: "Force Re-authentication",
        description: "Receiver requires the user to re-authenticate with new credentials before continuing.",
        from: "Receiver (RP)",
        to: "User",
        type: "redirect",
        parameters: {
          action: "Redirect to IdP for fresh authentication",
          prompt: "login (force new authentication)",
          message: "Your credentials have changed - please sign in again",
        },
        security: [
          "Force new authentication, not session refresh",
          "Consider user experience messaging",
          "Log forced re-auth events",
        ],
      },
    ]
  },

  'risc_account_disabled': {
    title: "Account Disabled Event (RISC)",
    description: "Risk Incident Sharing event indicating a user account has been suspended or disabled. Receiving systems must immediately block access for the affected user (RISC §2.2).",
    steps: [
      {
        order: 1,
        name: "Account Disabled",
        description: "Administrator or automated policy disables a user account at the Identity Provider.",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          reason: "Policy violation | Security incident | Offboarding | Admin action",
          initiating_entity: "admin | policy | system",
          scope: "Full account suspension",
        },
        security: [
          "Account disable requires elevated privileges",
          "Log disable reason for compliance",
          "Consider data retention requirements",
        ],
      },
      {
        order: 2,
        name: "Create Account Disabled SET",
        description: "IdP creates a Security Event Token for the account-disabled event type (RISC §2.2).",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          event_type: "https://schemas.openid.net/secevent/risc/event-type/account-disabled",
          sub_id: "Subject identifier",
          event_timestamp: "When account was disabled",
          initiating_entity: "admin | policy | system",
          reason_admin: "Detailed reason for administrators",
          reason_user: "User-appropriate explanation",
        },
        security: [
          "RISC events are high-severity security signals",
          "Immediate action required by all Receivers",
          "reason_admin may contain sensitive investigation details",
        ],
      },
      {
        order: 3,
        name: "Deliver SET to Receivers",
        description: "Transmitter urgently sends the account-disabled event to all subscribed Receivers.",
        from: "Transmitter",
        to: "All Subscribed Receivers",
        type: "request",
        parameters: {
          priority: "High - RISC events are security-critical",
          delivery: "Push preferred for immediate action",
          retry: "Aggressive retry for delivery assurance",
        },
      },
      {
        order: 4,
        name: "Receiver Validates SET",
        description: "Receiver validates the SET - RISC events require immediate attention after validation.",
        from: "Receiver (RP)",
        to: "Receiver (RP)",
        type: "internal",
        parameters: {
          signature: "Verify against JWKS",
          priority: "Process RISC events immediately",
          logging: "Enhanced logging for security events",
        },
      },
      {
        order: 5,
        name: "Block All Access",
        description: "Receiver immediately blocks all access for the disabled account. No operations should be permitted.",
        from: "Receiver (RP)",
        to: "Access Control",
        type: "internal",
        parameters: {
          sessions: "Terminate all active sessions immediately",
          tokens: "Revoke all access and refresh tokens",
          api_access: "Block API key access",
          new_auth: "Block new authentication attempts",
        },
        security: [
          "Complete access revocation is mandatory",
          "Consider data access restrictions",
          "Log all blocked access attempts",
        ],
      },
      {
        order: 6,
        name: "Update Local Account State",
        description: "Receiver updates local account records to reflect disabled status. Future operations should check this flag.",
        from: "Receiver (RP)",
        to: "User Store",
        type: "internal",
        parameters: {
          status: "Set account status to disabled/suspended",
          flag: "Mark account as externally disabled",
          timestamp: "Record when disable signal received",
        },
        security: [
          "Persist disabled state for future requests",
          "Consider sync with re-enable events",
          "Audit trail for compliance",
        ],
      },
    ]
  },

  'risc_credential_compromise': {
    title: "Credential Compromise Event (RISC)",
    description: "Critical security event indicating a user's credentials may have been compromised. This is a high-severity RISC event requiring immediate protective action including forced password reset and session termination (RISC §2.1).",
    steps: [
      {
        order: 1,
        name: "Compromise Detection",
        description: "Identity Provider detects potential credential compromise through various signals: breach database match, anomalous activity, or external report.",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          detection_source: "Breach database | Anomaly detection | External report | User report",
          confidence: "Detection confidence level",
          affected_credentials: "Password, tokens, API keys, etc.",
        },
        security: [
          "Compromise signals may come from external sources",
          "Consider confidence level in response severity",
          "Preserve evidence for investigation",
        ],
      },
      {
        order: 2,
        name: "Create Credential Compromise SET",
        description: "IdP creates a high-priority Security Event Token for the credential-compromise event type (RISC §2.1).",
        from: "Identity Provider",
        to: "Identity Provider",
        type: "internal",
        parameters: {
          event_type: "https://schemas.openid.net/secevent/risc/event-type/credential-compromise",
          sub_id: "Subject identifier",
          event_timestamp: "When compromise was detected",
          initiating_entity: "system (typically automated detection)",
          reason_admin: "Detailed compromise information",
          credential_type: "Type of credential potentially compromised (optional)",
        },
        security: [
          "CRITICAL: This is the highest severity RISC event",
          "Immediate action required across all systems",
          "Do not include compromised credential values",
        ],
      },
      {
        order: 3,
        name: "Emergency Delivery",
        description: "Transmitter urgently delivers the compromise event with highest priority. Push delivery is strongly preferred.",
        from: "Transmitter",
        to: "All Subscribed Receivers",
        type: "request",
        parameters: {
          priority: "CRITICAL - immediate delivery required",
          delivery: "Push strongly preferred",
          retry: "Aggressive retry until delivered",
          monitoring: "Alert on delivery failures",
        },
      },
      {
        order: 4,
        name: "Receiver Validates SET",
        description: "Receiver validates the SET with priority processing for compromise events.",
        from: "Receiver (RP)",
        to: "Receiver (RP)",
        type: "internal",
        parameters: {
          priority: "Bypass normal queue - process immediately",
          signature: "Verify against JWKS",
          alert: "Trigger security alert",
        },
      },
      {
        order: 5,
        name: "Terminate All Sessions",
        description: "Receiver immediately terminates ALL sessions for the affected user globally.",
        from: "Receiver (RP)",
        to: "Session Store",
        type: "internal",
        parameters: {
          scope: "All sessions across all devices",
          action: "Immediate termination",
          logging: "Security event logging",
        },
        security: [
          "No grace period - immediate termination",
          "Include all device types and locations",
          "Log termination for incident response",
        ],
      },
      {
        order: 6,
        name: "Revoke All Tokens and Keys",
        description: "Receiver revokes ALL access tokens, refresh tokens, API keys, and any other credentials for the affected user.",
        from: "Receiver (RP)",
        to: "Token Store",
        type: "internal",
        parameters: {
          access_tokens: "Revoke all",
          refresh_tokens: "Revoke all",
          api_keys: "Revoke all",
          certificates: "Consider certificate revocation",
        },
        security: [
          "Complete credential revocation",
          "Add to token blacklist if using JWTs",
          "Consider downstream service tokens",
        ],
      },
      {
        order: 7,
        name: "Force Password Reset",
        description: "Receiver flags account for mandatory password reset. User cannot access any resources until credentials are changed.",
        from: "Receiver (RP)",
        to: "User Store",
        type: "internal",
        parameters: {
          password_reset: "Required on next login",
          mfa_review: "Consider requiring MFA re-enrollment",
          account_state: "Limited until reset complete",
        },
        security: [
          "Password reset is mandatory, not optional",
          "Consider MFA re-enrollment",
          "Limit account functionality until reset",
        ],
      },
      {
        order: 8,
        name: "Alert Security Team",
        description: "Receiver triggers security alerts and may initiate incident response procedures.",
        from: "Receiver (RP)",
        to: "Security Operations",
        type: "internal",
        parameters: {
          alert: "High-severity security alert",
          incident: "May trigger incident response",
          investigation: "Preserve logs for investigation",
        },
        security: [
          "Credential compromise may indicate broader attack",
          "Preserve evidence for forensics",
          "Consider notifying affected user",
        ],
      },
    ]
  },
}

/**
 * Map URL slugs to flow IDs
 */
export const flowIdMap: Record<string, string> = {
  // OAuth 2.0 flows
  'authorization-code': 'authorization_code',
  'authorization-code-pkce': 'authorization_code_pkce',
  'client-credentials': 'client_credentials',
  'refresh-token': 'refresh_token',
  'token-introspection': 'token_introspection',
  'token-revocation': 'token_revocation',
  // OIDC flows
  'oidc-code': 'oidc_authorization_code',
  'oidc-authorization-code': 'oidc_authorization_code',
  'oidc-implicit': 'oidc_implicit',
  'oidc_implicit': 'oidc_implicit',
  'hybrid': 'oidc_hybrid',
  'userinfo': 'oidc_userinfo',
  'discovery': 'oidc_discovery',
  // SAML 2.0 flows
  'sp-initiated-sso': 'saml_sp_initiated_sso',
  'idp-initiated-sso': 'saml_idp_initiated_sso',
  'single-logout': 'saml_single_logout',
  'metadata': 'saml_metadata',
  // SPIFFE/SPIRE flows (use consistent hyphenated format)
  'x509-svid-issuance': 'x509-svid-issuance',
  'jwt-svid-issuance': 'jwt-svid-issuance',
  'mtls-handshake': 'mtls-handshake',
  'certificate-rotation': 'certificate-rotation',
  // SCIM 2.0 flows
  'user-lifecycle': 'scim_user_lifecycle',
  'group-management': 'scim_group_management',
  'filter-queries': 'scim_filter_queries',
  'schema-discovery': 'scim_schema_discovery',
  'bulk-operations': 'scim_bulk_operations',
  // SSF (Shared Signals Framework) flows
  'ssf-stream-configuration': 'ssf_stream_configuration',
  'ssf-push-delivery': 'ssf_push_delivery',
  'ssf-poll-delivery': 'ssf_poll_delivery',
  'caep-session-revoked': 'caep_session_revoked',
  'caep-credential-change': 'caep_credential_change',
  'risc-account-disabled': 'risc_account_disabled',
  'risc-credential-compromise': 'risc_credential_compromise',
}

/**
 * Get flow data with fallback to local data
 */
export function getFlowWithFallback(flowId: string): FlowData | undefined {
  const mappedId = flowIdMap[flowId] || flowId
  return fallbackFlows[mappedId]
}

